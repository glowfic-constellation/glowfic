# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `resque` gem.
# Please instead update this file by running `bin/tapioca gem resque`.

# only used with `bin/resque-web`
# https://github.com/resque/resque/pull/1780
#
# source://resque/lib/resque/version.rb#1
module Resque
  include ::Resque::Helpers
  extend ::Resque::Helpers
  extend ::Resque
  extend ::Forwardable

  # The `after_fork` hook will be run in the child process and is passed
  # the current job. Any changes you make, therefore, will only live as
  # long as the job currently being processed.
  #
  # Call with a block to register a hook.
  # Call with no arguments to return all registered hooks.
  #
  # source://resque/lib/resque.rb#260
  def after_fork(&block); end

  # Register an after_fork proc.
  #
  # source://resque/lib/resque.rb#265
  def after_fork=(block); end

  # The `after_pause` hook will be run in the parent process after the
  # worker has paused (via SIGCONT).
  #
  # source://resque/lib/resque.rb#282
  def after_pause(&block); end

  # Register an after_pause proc.
  #
  # source://resque/lib/resque.rb#287
  def after_pause=(block); end

  # The `before_first_fork` hook will be run in the **parent** process
  # only once, before forking to run the first job. Be careful- any
  # changes you make will be permanent for the lifespan of the
  # worker.
  #
  # Call with a block to register a hook.
  # Call with no arguments to return all registered hooks.
  #
  # source://resque/lib/resque.rb#230
  def before_first_fork(&block); end

  # Register a before_first_fork proc.
  #
  # source://resque/lib/resque.rb#235
  def before_first_fork=(block); end

  # The `before_fork` hook will be run in the **parent** process
  # before every job, so be careful- any changes you make will be
  # permanent for the lifespan of the worker.
  #
  # Call with a block to register a hook.
  # Call with no arguments to return all registered hooks.
  #
  # source://resque/lib/resque.rb#245
  def before_fork(&block); end

  # Register a before_fork proc.
  #
  # source://resque/lib/resque.rb#250
  def before_fork=(block); end

  # The `before_pause` hook will be run in the parent process before the
  # worker has paused processing (via #pause_processing or SIGUSR2).
  #
  # source://resque/lib/resque.rb#271
  def before_pause(&block); end

  # Register a before_pause proc.
  #
  # source://resque/lib/resque.rb#276
  def before_pause=(block); end

  # Given a word with dashes, returns a camel cased version of it.
  #
  # classify('job-name') # => 'JobName'
  #
  # source://resque/lib/resque.rb#60
  def classify(dashed_word); end

  # Tries to find a constant with the name specified in the argument string:
  #
  # constantize("Module") # => Module
  # constantize("Test::Unit") # => Test::Unit
  #
  # The name is assumed to be the one of a top-level constant, no matter
  # whether it starts with "::" or not. No lexical context is taken into
  # account:
  #
  # C = 'outside'
  # module M
  #   C = 'inside'
  #   C # => 'inside'
  #   constantize("C") # => 'outside', same as ::C
  # end
  #
  # NameError is raised when the constant is unknown.
  #
  # source://resque/lib/resque.rb#81
  def constantize(camel_cased_word); end

  # Returns the current Redis connection. If none has been created, will
  # create a new one.
  #
  # source://resque/lib/resque.rb#140
  def data_store; end

  # Given a string, returns a Ruby object.
  #
  # source://resque/lib/resque.rb#43
  def decode(object); end

  # This method can be used to conveniently remove a job from a queue.
  # It assumes the class you're passing it is a real Ruby class (not
  # a string or reference) which either:
  #
  #   a) has a @queue ivar set
  #   b) responds to `queue`
  #
  # If either of those conditions are met, it will use the value obtained
  # from performing one of the above operations to determine the queue.
  #
  # If no queue can be inferred this method will raise a `Resque::NoQueueError`
  #
  # If no args are given, this method will dequeue *all* jobs matching
  # the provided class. See `Resque::Job.destroy` for more
  # information.
  #
  # Returns the number of jobs destroyed.
  #
  # Example:
  #
  #   # Removes all jobs of class `UpdateNetworkGraph`
  #   Resque.dequeue(GitHub::Jobs::UpdateNetworkGraph)
  #
  #   # Removes all jobs of class `UpdateNetworkGraph` with matching args.
  #   Resque.dequeue(GitHub::Jobs::UpdateNetworkGraph, 'repo:135325')
  #
  # This method is considered part of the `stable` API.
  #
  # source://resque/lib/resque.rb#487
  def dequeue(klass, *args); end

  # Given a Ruby object, returns a string suitable for storage in a
  # queue.
  #
  # source://resque/lib/resque.rb#34
  def encode(object); end

  # This method can be used to conveniently add a job to a queue.
  # It assumes the class you're passing it is a real Ruby class (not
  # a string or reference) which either:
  #
  #   a) has a @queue ivar set
  #   b) responds to `queue`
  #
  # If either of those conditions are met, it will use the value obtained
  # from performing one of the above operations to determine the queue.
  #
  # If no queue can be inferred this method will raise a `Resque::NoQueueError`
  #
  # Returns true if the job was queued, nil if the job was rejected by a
  # before_enqueue hook.
  #
  # This method is considered part of the `stable` API.
  #
  # source://resque_spec/0.18.1lib/resque_spec/ext.rb#38
  def enqueue(klass, *args); end

  # source://resque/lib/resque.rb#215
  def enqueue_front; end

  # By default, jobs are pushed to the back of the queue and popped from
  # the front, resulting in "first in, first out" (FIFO) execution order.
  # Set to true to push jobs to the front of the queue instead, resulting
  # in "last in, first out" (LIFO) execution order.
  #
  # source://resque/lib/resque.rb#214
  def enqueue_front=(_arg0); end

  # Just like `enqueue` but allows you to specify the queue you want to
  # use. Runs hooks.
  #
  # `queue` should be the String name of the queue you're targeting.
  #
  # Returns true if the job was queued, nil if the job was rejected by a
  # before_enqueue hook.
  #
  # This method is considered part of the `stable` API.
  #
  # source://resque_spec/0.18.1lib/resque_spec/ext.rb#44
  def enqueue_to(queue, klass, *args); end

  # source://resque/lib/resque.rb#444
  def enqueue_to_without_resque_spec(queue, klass, *args); end

  # source://resque/lib/resque.rb#431
  def enqueue_without_resque_spec(klass, *args); end

  # source://resque/lib/resque.rb#192
  def heartbeat_interval; end

  # Defines how often a Resque worker updates the heartbeat key. Must be less
  # than the prune interval.
  #
  # source://resque/lib/resque.rb#191
  def heartbeat_interval=(_arg0); end

  # Returns a hash, similar to redis-rb's #info, of interesting stats.
  #
  # source://resque/lib/resque.rb#563
  def info; end

  # Returns the value of attribute inline.
  #
  # source://resque/lib/resque.rb#323
  def inline; end

  # Sets the attribute inline
  #
  # @param value the value to set the attribute inline to.
  #
  # source://resque/lib/resque.rb#323
  def inline=(_arg0); end

  # Returns the value of attribute inline.
  # If 'inline' is true Resque will call #perform method inline
  # without queuing it into Redis and without any Resque callbacks.
  # The 'inline' is false Resque jobs will be put in queue regularly.
  def inline?; end

  # Returns an array of all known Resque keys in Redis. Redis' KEYS operation
  # is O(N) for the keyspace, so be careful - this can be slow for big databases.
  #
  # source://resque/lib/resque.rb#578
  def keys; end

  # Does the dirty work of fetching a range of items from a Redis list
  # and converting them into Ruby objects.
  #
  # source://resque/lib/resque.rb#385
  def list_range(key, start = T.unsafe(nil), count = T.unsafe(nil)); end

  # Set or retrieve the current logger object
  #
  # source://resque/lib/resque.rb#184
  def logger; end

  # Set or retrieve the current logger object
  #
  # source://resque/lib/resque.rb#184
  def logger=(_arg0); end

  # Returns an array of items currently queued, or the item itself
  # if count = 1. Queue name should be a string.
  #
  # start and count should be integer and can be used for pagination.
  # start is the item to begin, count is how many items to return.
  #
  # To get the 3rd page of a 30 item, paginatied list one would use:
  #   Resque.peek('my_list', 59, 30)
  #
  # source://resque_spec/0.18.1lib/resque_spec/ext.rb#59
  def peek(queue, start = T.unsafe(nil), count = T.unsafe(nil)); end

  # source://resque/lib/resque.rb#374
  def peek_without_resque_spec(queue, start = T.unsafe(nil), count = T.unsafe(nil)); end

  # Pops a job off a queue. Queue name should be a string.
  #
  # Returns a Ruby object.
  #
  # source://resque/lib/resque.rb#356
  def pop(queue); end

  # source://resque/lib/resque.rb#202
  def prune_interval; end

  # Defines how often Resque checks for dead workers.
  #
  # source://resque/lib/resque.rb#201
  def prune_interval=(_arg0); end

  # Pushes a job onto a queue. Queue name should be a string and the
  # item should be any JSON-able Ruby object.
  #
  # Resque works generally expect the `item` to be a hash with the following
  # keys:
  #
  #   class - The String name of the job to run.
  #    args - An Array of arguments to pass the job. Usually passed
  #           via `class.to_class.perform(*args)`.
  #
  # Example
  #
  #   Resque.push('archive', :class => 'Archive', :args => [ 35, 'tar' ])
  #
  # Returns nothing
  #
  # source://resque/lib/resque.rb#349
  def push(queue, item); end

  # The `queue_empty` hook will be run in the **parent** process when
  # the worker finds no more jobs in the queue and becomes idle.
  #
  # Call with a block to register a hook.
  # Call with no arguments to return all registered hooks.
  #
  # source://resque/lib/resque.rb#296
  def queue_empty(&block); end

  # Register a queue_empty proc.
  #
  # source://resque/lib/resque.rb#301
  def queue_empty=(block); end

  # Given a class, try to extrapolate an appropriate queue based on a
  # class instance variable or `queue` method.
  #
  # source://resque/lib/resque.rb#505
  def queue_from_class(klass); end

  # Returns a hash, mapping queue names to queue sizes
  #
  # source://resque/lib/resque.rb#583
  def queue_sizes; end

  # Returns an array of all known Resque queues as strings.
  #
  # source://resque/lib/resque.rb#395
  def queues; end

  # Returns the current Redis connection. If none has been created, will
  # create a new one.
  #
  # source://resque/lib/resque.rb#140
  def redis; end

  # Accepts:
  #   1. A 'hostname:port' String
  #   2. A 'hostname:port:db' String (to select the Redis db)
  #   3. A 'hostname:port/namespace' String (to set the Redis namespace)
  #   4. A Redis URL String 'redis://host:port'
  #   5. An instance of `Redis`, `Redis::Client`, `Redis::DistRedis`,
  #      or `Redis::Namespace`.
  #   6. An Hash of a redis connection {:host => 'localhost', :port => 6379, :db => 0}
  #
  # source://resque/lib/resque.rb#114
  def redis=(server); end

  # source://resque/lib/resque.rb#147
  def redis_id; end

  # Given a queue name, completely deletes the queue.
  #
  # source://resque/lib/resque.rb#400
  def remove_queue(queue); end

  # A shortcut to unregister_worker
  # useful for command line tool
  #
  # source://resque/lib/resque.rb#553
  def remove_worker(worker_id); end

  # This method will return a `Resque::Job` object or a non-true value
  # depending on whether a job can be obtained. You should pass it the
  # precise name of a queue: case matters.
  #
  # This method is considered part of the `stable` API.
  #
  # source://resque_spec/0.18.1lib/resque_spec/ext.rb#66
  def reserve(queue_name); end

  # source://resque/lib/resque.rb#515
  def reserve_without_resque_spec(queue); end

  # Returns a hash, mapping queue names to (up to `sample_size`) samples of jobs in that queue
  #
  # source://resque/lib/resque.rb#596
  def sample_queues(sample_size = T.unsafe(nil)); end

  # Returns an integer representing the size of a queue.
  # Queue name should be a string.
  #
  # source://resque_spec/0.18.1lib/resque_spec/ext.rb#72
  def size(queue_name); end

  # source://resque/lib/resque.rb#362
  def size_without_resque_spec(queue); end

  # Returns the data store for the statistics module.
  #
  # source://resque/lib/resque.rb#179
  def stat_data_store; end

  # Set the data store for the processed and failed statistics.
  #
  # By default it uses the same as `Resque.redis`, but different stores can be used.
  #
  # A custom store needs to obey the following API to work correctly
  #
  # class NullDataStore
  #   # Returns the current value for the given stat.
  #   def stat(stat)
  #   end
  #
  #   # Increments the stat by the given value.
  #   def increment_stat(stat, by)
  #   end
  #
  #   # Decrements the stat by the given value.
  #   def decrement_stat(stat, by)
  #   end
  #
  #   # Clear the values for the given stat.
  #   def clear_stat(stat)
  #   end
  # end
  #
  # source://resque/lib/resque.rb#174
  def stat_data_store=(stat_data_store); end

  # source://resque/lib/resque.rb#319
  def to_s; end

  # Validates if the given klass could be a valid Resque job
  #
  # If no queue can be inferred this method will raise a `Resque::NoQueueError`
  #
  # If given klass is nil this method will raise a `Resque::NoClassError`
  #
  # source://resque/lib/resque.rb#524
  def validate(klass, queue = T.unsafe(nil)); end

  # Used internally to keep track of which queues we've created.
  # Don't call this directly.
  #
  # source://resque/lib/resque.rb#406
  def watch_queue(queue); end

  # The `worker_exit` hook will be run in the **parent** process
  # after the worker has existed (via SIGQUIT, SIGTERM, SIGINT, etc.).
  #
  # Call with a block to register a hook.
  # Call with no arguments to return all registered hooks.
  #
  # source://resque/lib/resque.rb#310
  def worker_exit(&block); end

  # Register a worker_exit proc.
  #
  # source://resque/lib/resque.rb#315
  def worker_exit=(block); end

  # A shortcut to Worker.all
  #
  # source://resque/lib/resque.rb#542
  def workers; end

  # A shortcut to Worker.working
  #
  # source://resque/lib/resque.rb#547
  def working; end

  private

  # Clear all hooks given a hook name.
  #
  # source://resque/lib/resque.rb#639
  def clear_hooks(name); end

  # Retrieve all hooks of a given name.
  #
  # source://resque/lib/resque.rb#644
  def hooks(name); end

  # Register a new proc as a hook. If the block is nil this is the
  # equivalent of removing all hooks of the given name.
  #
  # `name` is the hook that the block should be registered with.
  #
  # source://resque/lib/resque.rb#631
  def register_hook(name, block); end

  # source://resque_spec/0.18.1lib/resque_spec/ext.rb#80
  def run_after_enqueue(klass, *args); end

  # source://resque_spec/0.18.1lib/resque_spec/ext.rb#86
  def run_before_enqueue(klass, *args); end

  class << self
    # source://resque-heroku-signals/2.6.0lib/resque-heroku-signals.rb#6
    def heroku_will_terminate?; end
  end
end

# source://resque/lib/resque.rb#186
Resque::DEFAULT_HEARTBEAT_INTERVAL = T.let(T.unsafe(nil), Integer)

# source://resque/lib/resque.rb#187
Resque::DEFAULT_PRUNE_INTERVAL = T.let(T.unsafe(nil), Integer)

# An interface between Resque's persistence and the actual
# implementation.
#
# source://resque/lib/resque/data_store.rb#4
class Resque::DataStore
  extend ::Forwardable

  # @return [DataStore] a new instance of DataStore
  #
  # source://resque/lib/resque/data_store.rb#9
  def initialize(redis); end

  # source://forwardable/1.3.3forwardable.rb#231
  def acquire_pruning_dead_worker_lock(*args, **_arg1, &block); end

  # source://forwardable/1.3.3forwardable.rb#231
  def add_failed_queue(*args, **_arg1, &block); end

  # source://forwardable/1.3.3forwardable.rb#231
  def all_heartbeats(*args, **_arg1, &block); end

  # Returns an array of all known Resque keys in Redis. Redis' KEYS operation
  # is O(N) for the keyspace, so be careful - this can be slow for big databases.
  #
  # source://resque/lib/resque/data_store.rb#89
  def all_resque_keys; end

  # source://forwardable/1.3.3forwardable.rb#231
  def clear_failed_queue(*args, **_arg1, &block); end

  # source://forwardable/1.3.3forwardable.rb#231
  def clear_stat(*args, **_arg1, &block); end

  # source://forwardable/1.3.3forwardable.rb#231
  def decrement_stat(*args, **_arg1, &block); end

  # source://resque/lib/resque/data_store.rb#57
  def decremet_stat(*args); end

  # source://forwardable/1.3.3forwardable.rb#231
  def everything_in_queue(*args, **_arg1, &block); end

  # source://forwardable/1.3.3forwardable.rb#231
  def failed_queue_names(*args, **_arg1, &block); end

  # source://forwardable/1.3.3forwardable.rb#231
  def get_worker_payload(*args, **_arg1, &block); end

  # source://forwardable/1.3.3forwardable.rb#231
  def heartbeat(*args, **_arg1, &block); end

  # source://forwardable/1.3.3forwardable.rb#231
  def heartbeat!(*args, **_arg1, &block); end

  # Get a string identifying the underlying server.
  # Probably should be private, but was public so must stay public
  #
  # source://resque/lib/resque/data_store.rb#75
  def identifier; end

  # source://forwardable/1.3.3forwardable.rb#231
  def increment_stat(*args, **_arg1, &block); end

  # source://forwardable/1.3.3forwardable.rb#231
  def list_range(*args, **_arg1, &block); end

  # Compatibility with any non-Resque classes that were using Resque.redis as a way to access Redis
  #
  # source://resque/lib/resque/data_store.rb#63
  def method_missing(sym, *args, &block); end

  # source://forwardable/1.3.3forwardable.rb#231
  def num_failed(*args, **_arg1, &block); end

  # source://forwardable/1.3.3forwardable.rb#231
  def peek_in_queue(*args, **_arg1, &block); end

  # source://forwardable/1.3.3forwardable.rb#231
  def pop_from_queue(*args, **_arg1, &block); end

  # source://forwardable/1.3.3forwardable.rb#231
  def push_to_failed_queue(*args, **_arg1, &block); end

  # source://forwardable/1.3.3forwardable.rb#231
  def push_to_queue(*args, **_arg1, &block); end

  # source://forwardable/1.3.3forwardable.rb#231
  def queue_names(*args, **_arg1, &block); end

  # source://forwardable/1.3.3forwardable.rb#231
  def queue_size(*args, **_arg1, &block); end

  # Force a reconnect to Redis without closing the connection in the parent
  # process after a fork.
  #
  # source://resque/lib/resque/data_store.rb#81
  def reconnect; end

  # source://forwardable/1.3.3forwardable.rb#231
  def register_worker(*args, **_arg1, &block); end

  # source://forwardable/1.3.3forwardable.rb#231
  def remove_failed_queue(*args, **_arg1, &block); end

  # source://forwardable/1.3.3forwardable.rb#231
  def remove_from_failed_queue(*args, **_arg1, &block); end

  # source://forwardable/1.3.3forwardable.rb#231
  def remove_from_queue(*args, **_arg1, &block); end

  # source://forwardable/1.3.3forwardable.rb#231
  def remove_heartbeat(*args, **_arg1, &block); end

  # source://forwardable/1.3.3forwardable.rb#231
  def remove_queue(*args, **_arg1, &block); end

  # make use respond like redis
  #
  # @return [Boolean]
  #
  # source://resque/lib/resque/data_store.rb#69
  def respond_to?(method, include_all = T.unsafe(nil)); end

  # source://resque/lib/resque/data_store.rb#95
  def server_time; end

  # source://forwardable/1.3.3forwardable.rb#231
  def set_worker_payload(*args, **_arg1, &block); end

  # source://forwardable/1.3.3forwardable.rb#231
  def stat(*args, **_arg1, &block); end

  # source://forwardable/1.3.3forwardable.rb#231
  def unregister_worker(*args, **_arg1, &block); end

  # source://forwardable/1.3.3forwardable.rb#231
  def update_item_in_failed_queue(*args, **_arg1, &block); end

  # source://forwardable/1.3.3forwardable.rb#231
  def watch_queue(*args, **_arg1, &block); end

  # source://forwardable/1.3.3forwardable.rb#231
  def worker_done_working(*args, **_arg1, &block); end

  # source://forwardable/1.3.3forwardable.rb#231
  def worker_exists?(*args, **_arg1, &block); end

  # source://forwardable/1.3.3forwardable.rb#231
  def worker_ids(*args, **_arg1, &block); end

  # source://forwardable/1.3.3forwardable.rb#231
  def worker_start_time(*args, **_arg1, &block); end

  # source://forwardable/1.3.3forwardable.rb#231
  def worker_started(*args, **_arg1, &block); end

  # source://forwardable/1.3.3forwardable.rb#231
  def workers_map(*args, **_arg1, &block); end
end

# source://resque/lib/resque/data_store.rb#171
class Resque::DataStore::FailedQueueAccess
  # @return [FailedQueueAccess] a new instance of FailedQueueAccess
  #
  # source://resque/lib/resque/data_store.rb#172
  def initialize(redis); end

  # source://resque/lib/resque/data_store.rb#176
  def add_failed_queue(failed_queue_name); end

  # source://resque/lib/resque/data_store.rb#200
  def clear_failed_queue(failed_queue_name = T.unsafe(nil)); end

  # source://resque/lib/resque/data_store.rb#188
  def failed_queue_names(find_queue_names_in_key = T.unsafe(nil)); end

  # source://resque/lib/resque/data_store.rb#184
  def num_failed(failed_queue_name = T.unsafe(nil)); end

  # source://resque/lib/resque/data_store.rb#196
  def push_to_failed_queue(data, failed_queue_name = T.unsafe(nil)); end

  # source://resque/lib/resque/data_store.rb#180
  def remove_failed_queue(failed_queue_name = T.unsafe(nil)); end

  # source://resque/lib/resque/data_store.rb#208
  def remove_from_failed_queue(index_in_failed_queue, failed_queue_name = T.unsafe(nil)); end

  # source://resque/lib/resque/data_store.rb#204
  def update_item_in_failed_queue(index_in_failed_queue, new_item_data, failed_queue_name = T.unsafe(nil)); end
end

# source://resque/lib/resque/data_store.rb#7
Resque::DataStore::HEARTBEAT_KEY = T.let(T.unsafe(nil), String)

# source://resque/lib/resque/data_store.rb#100
class Resque::DataStore::QueueAccess
  # @return [QueueAccess] a new instance of QueueAccess
  #
  # source://resque/lib/resque/data_store.rb#101
  def initialize(redis); end

  # source://resque/lib/resque/data_store.rb#140
  def everything_in_queue(queue); end

  # Private: do not call
  #
  # source://resque/lib/resque/data_store.rb#155
  def list_range(key, start = T.unsafe(nil), count = T.unsafe(nil)); end

  # Examine items in the queue.
  #
  # NOTE: if count is 1, you will get back an object, otherwise you will
  #       get an Array.  I'm not making this up.
  #
  # source://resque/lib/resque/data_store.rb#125
  def peek_in_queue(queue, start = T.unsafe(nil), count = T.unsafe(nil)); end

  # Pop whatever is on queue
  #
  # source://resque/lib/resque/data_store.rb#112
  def pop_from_queue(queue); end

  # source://resque/lib/resque/data_store.rb#104
  def push_to_queue(queue, encoded_item); end

  # source://resque/lib/resque/data_store.rb#129
  def queue_names; end

  # Get the number of items in the queue
  #
  # source://resque/lib/resque/data_store.rb#117
  def queue_size(queue); end

  # Remove data from the queue, if it's there, returning the number of removed elements
  #
  # source://resque/lib/resque/data_store.rb#145
  def remove_from_queue(queue, data); end

  # source://resque/lib/resque/data_store.rb#133
  def remove_queue(queue); end

  # Private: do not call
  #
  # source://resque/lib/resque/data_store.rb#150
  def watch_queue(queue, redis: T.unsafe(nil)); end

  private

  # source://resque/lib/resque/data_store.rb#165
  def redis_key_for_queue(queue); end
end

# source://resque/lib/resque/data_store.rb#314
class Resque::DataStore::StatsAccess
  # @return [StatsAccess] a new instance of StatsAccess
  #
  # source://resque/lib/resque/data_store.rb#315
  def initialize(redis); end

  # source://resque/lib/resque/data_store.rb#330
  def clear_stat(stat, redis: T.unsafe(nil)); end

  # source://resque/lib/resque/data_store.rb#326
  def decremet_stat(stat, by = T.unsafe(nil)); end

  # source://resque/lib/resque/data_store.rb#322
  def increment_stat(stat, by = T.unsafe(nil), redis: T.unsafe(nil)); end

  # source://resque/lib/resque/data_store.rb#318
  def stat(stat); end
end

# source://resque/lib/resque/data_store.rb#216
class Resque::DataStore::Workers
  # @return [Workers] a new instance of Workers
  #
  # source://resque/lib/resque/data_store.rb#217
  def initialize(redis); end

  # source://resque/lib/resque/data_store.rb#280
  def acquire_pruning_dead_worker_lock(worker, expiry); end

  # source://resque/lib/resque/data_store.rb#276
  def all_heartbeats; end

  # return the worker's payload i.e. job
  #
  # source://resque/lib/resque/data_store.rb#233
  def get_worker_payload(worker_id); end

  # source://resque/lib/resque/data_store.rb#267
  def heartbeat(worker); end

  # source://resque/lib/resque/data_store.rb#272
  def heartbeat!(worker, time); end

  # source://resque/lib/resque/data_store.rb#241
  def register_worker(worker); end

  # source://resque/lib/resque/data_store.rb#263
  def remove_heartbeat(worker); end

  # source://resque/lib/resque/data_store.rb#284
  def set_worker_payload(worker, data); end

  # source://resque/lib/resque/data_store.rb#252
  def unregister_worker(worker, &block); end

  # source://resque/lib/resque/data_store.rb#292
  def worker_done_working(worker, &block); end

  # @return [Boolean]
  #
  # source://resque/lib/resque/data_store.rb#237
  def worker_exists?(worker_id); end

  # source://resque/lib/resque/data_store.rb#221
  def worker_ids; end

  # source://resque/lib/resque/data_store.rb#288
  def worker_start_time(worker); end

  # source://resque/lib/resque/data_store.rb#248
  def worker_started(worker, redis: T.unsafe(nil)); end

  # Given a list of worker ids, returns a map of those ids to the worker's value
  # in redis, even if that value maps to nil
  #
  # source://resque/lib/resque/data_store.rb#227
  def workers_map(worker_ids); end

  private

  # source://resque/lib/resque/data_store.rb#301
  def redis_key_for_worker(worker); end

  # source://resque/lib/resque/data_store.rb#309
  def redis_key_for_worker_pruning; end

  # source://resque/lib/resque/data_store.rb#305
  def redis_key_for_worker_start_time(worker); end
end

# Raised when a worker was killed while processing a job.
#
# source://resque/lib/resque/errors.rb#9
class Resque::DirtyExit < ::RuntimeError
  # @return [DirtyExit] a new instance of DirtyExit
  #
  # source://resque/lib/resque/errors.rb#12
  def initialize(message = T.unsafe(nil), process_status = T.unsafe(nil)); end

  # Returns the value of attribute process_status.
  #
  # source://resque/lib/resque/errors.rb#10
  def process_status; end
end

# The Failure module provides an interface for working with different
# failure backends.
#
# You can use it to query the failure backend without knowing which specific
# backend is being used. For instance, the Resque web app uses it to display
# stats and other information.
#
# source://resque/lib/resque/failure.rb#8
module Resque::Failure
  class << self
    # Returns an array of all the failures, paginated.
    #
    # `offset` is the int of the first item in the page, `limit` is the
    # number of items to return.
    #
    # source://resque/lib/resque/failure.rb#75
    def all(offset = T.unsafe(nil), limit = T.unsafe(nil), queue = T.unsafe(nil)); end

    # Returns the current backend class. If none has been set, falls
    # back to `Resque::Failure::Redis`
    #
    # source://resque/lib/resque/failure.rb#34
    def backend; end

    # Sets the current backend. Expects a class descendent of
    # `Resque::Failure::Base`.
    #
    # Example use:
    #   require 'resque/failure/airbrake'
    #   Resque::Failure.backend = Resque::Failure::Airbrake
    #
    # source://resque/lib/resque/failure.rb#27
    def backend=(backend); end

    # Clear all failure jobs
    #
    # source://resque/lib/resque/failure.rb#90
    def clear(queue = T.unsafe(nil)); end

    # source://resque/lib/resque/failure.rb#94
    def clear_retried; end

    # Returns the int count of how many failures we have seen.
    #
    # source://resque/lib/resque/failure.rb#67
    def count(queue = T.unsafe(nil), class_name = T.unsafe(nil)); end

    # Creates a new failure, which is delegated to the appropriate backend.
    #
    # Expects a hash with the following keys:
    #   :exception - The Exception object
    #   :worker    - The Worker object who is reporting the failure
    #   :queue     - The string name of the queue from which the job was pulled
    #   :payload   - The job's payload
    #
    # source://resque/lib/resque/failure.rb#16
    def create(options = T.unsafe(nil)); end

    # Iterate across all failures with the given options
    #
    # source://resque/lib/resque/failure.rb#80
    def each(offset = T.unsafe(nil), limit = T.unsafe(nil), queue = T.unsafe(nil), class_name = T.unsafe(nil), order = T.unsafe(nil), &block); end

    # Obtain the failure queue name for a given job queue
    #
    # source://resque/lib/resque/failure.rb#50
    def failure_queue_name(job_queue_name); end

    # Obtain the job queue name for a given failure queue
    #
    # source://resque/lib/resque/failure.rb#57
    def job_queue_name(failure_queue_name); end

    # Returns an array of all the failed queues in the system
    #
    # source://resque/lib/resque/failure.rb#62
    def queues; end

    # source://resque/lib/resque/failure.rb#104
    def remove(id, queue = T.unsafe(nil)); end

    # Removes all failed jobs in a specific queue.
    # Queue name should be a string.
    #
    # source://resque/lib/resque/failure.rb#121
    def remove_queue(queue); end

    # source://resque/lib/resque/failure.rb#100
    def requeue(id, queue = T.unsafe(nil)); end

    # Requeues all failed jobs
    #
    # source://resque/lib/resque/failure.rb#115
    def requeue_all; end

    # Requeues all failed jobs in a specific queue.
    # Queue name should be a string.
    #
    # source://resque/lib/resque/failure.rb#110
    def requeue_queue(queue); end

    # The string url of the backend's web interface, if any.
    #
    # source://resque/lib/resque/failure.rb#85
    def url; end
  end
end

# All Failure classes are expected to subclass Base.
#
# When a job fails, a new instance of your Failure backend is created
# and #save is called.
#
# source://resque/lib/resque/failure/base.rb#7
class Resque::Failure::Base
  # @return [Base] a new instance of Base
  #
  # source://resque/lib/resque/failure/base.rb#20
  def initialize(exception, worker, queue, payload); end

  # The exception object raised by the failed job
  #
  # source://resque/lib/resque/failure/base.rb#9
  def exception; end

  # The exception object raised by the failed job
  #
  # source://resque/lib/resque/failure/base.rb#9
  def exception=(_arg0); end

  # Logging!
  #
  # source://resque/lib/resque/failure/base.rb#68
  def log(message); end

  # The payload object associated with the failed job
  #
  # source://resque/lib/resque/failure/base.rb#18
  def payload; end

  # The payload object associated with the failed job
  #
  # source://resque/lib/resque/failure/base.rb#18
  def payload=(_arg0); end

  # The string name of the queue from which the failed job was pulled
  #
  # source://resque/lib/resque/failure/base.rb#15
  def queue; end

  # The string name of the queue from which the failed job was pulled
  #
  # source://resque/lib/resque/failure/base.rb#15
  def queue=(_arg0); end

  # When a job fails, a new instance of your Failure backend is created
  # and #save is called.
  #
  # This is where you POST or PUT or whatever to your Failure service.
  #
  # source://resque/lib/resque/failure/base.rb#31
  def save; end

  # The worker object who detected the failure
  #
  # source://resque/lib/resque/failure/base.rb#12
  def worker; end

  # The worker object who detected the failure
  #
  # source://resque/lib/resque/failure/base.rb#12
  def worker=(_arg0); end

  class << self
    # Returns a paginated array of failure objects.
    #
    # source://resque/lib/resque/failure/base.rb#45
    def all(offset = T.unsafe(nil), limit = T.unsafe(nil), queue = T.unsafe(nil)); end

    # Clear all failure objects
    #
    # source://resque/lib/resque/failure/base.rb#58
    def clear(*args); end

    # The number of failures.
    #
    # source://resque/lib/resque/failure/base.rb#35
    def count(queue = T.unsafe(nil), class_name = T.unsafe(nil)); end

    # Iterate across failed objects
    #
    # source://resque/lib/resque/failure/base.rb#50
    def each(*args); end

    # Returns an array of all available failure queues
    #
    # source://resque/lib/resque/failure/base.rb#40
    def queues; end

    # source://resque/lib/resque/failure/base.rb#64
    def remove(*args); end

    # source://resque/lib/resque/failure/base.rb#61
    def requeue(*args); end

    # A URL where someone can go to view failures.
    #
    # source://resque/lib/resque/failure/base.rb#54
    def url; end
  end
end

# Methods used by various classes in Resque.
#
# source://resque/lib/resque/helpers.rb#13
module Resque::Helpers
  # Given a word with dashes, returns a camel cased version of it.
  #
  # source://resque/lib/resque/helpers.rb#39
  def classify(dashed_word); end

  # Tries to find a constant with the name specified in the argument string
  #
  # source://resque/lib/resque/helpers.rb#44
  def constantize(camel_cased_word); end

  # Given a string, returns a Ruby object.
  #
  # source://resque/lib/resque/helpers.rb#34
  def decode(object); end

  # Given a Ruby object, returns a string suitable for storage in a
  # queue.
  #
  # source://resque/lib/resque/helpers.rb#29
  def encode(object); end

  # Direct access to the Redis instance.
  #
  # source://resque/lib/resque/helpers.rb#17
  def redis; end
end

# source://resque/lib/resque/helpers.rb#14
class Resque::Helpers::DecodeException < ::StandardError; end

# A Resque::Job represents a unit of work. Each job lives on a
# single queue and has an associated payload object. The payload
# is a hash with two attributes: `class` and `args`. The `class` is
# the name of the Ruby class which should be used to run the
# job. The `args` are an array of arguments which should be passed
# to the Ruby class's `perform` class-level method.
#
# You can manually run a job using this code:
#
#   job = Resque::Job.reserve(:high)
#   klass = Resque::Job.constantize(job.payload['class'])
#   klass.perform(*job.payload['args'])
#
# source://resque/lib/resque/job.rb#14
class Resque::Job
  include ::Resque::Helpers
  extend ::Resque::Helpers

  # @return [Job] a new instance of Job
  #
  # source://resque/lib/resque/job.rb#76
  def initialize(queue, payload); end

  # Equality
  #
  # source://resque/lib/resque/job.rb#259
  def ==(other); end

  # source://resque/lib/resque/job.rb#273
  def after_hooks; end

  # Returns an array of args represented in this job's payload.
  #
  # source://resque/lib/resque/job.rb#226
  def args; end

  # source://resque/lib/resque/job.rb#269
  def around_hooks; end

  # source://resque/lib/resque/job.rb#265
  def before_hooks; end

  # Given a word with dashes, returns a camel cased version of it.
  #
  # source://resque/lib/resque/job.rb#53
  def classify(dashed_word); end

  # Tries to find a constant with the name specified in the argument string
  #
  # source://resque/lib/resque/job.rb#58
  def constantize(camel_cased_word); end

  # source://resque/lib/resque/job.rb#17
  def data_store; end

  # Given a string, returns a Ruby object.
  #
  # source://resque/lib/resque/job.rb#37
  def decode(object); end

  # Given a Ruby object, returns a string suitable for storage in a
  # queue.
  #
  # source://resque/lib/resque/job.rb#32
  def encode(object); end

  # Given an exception object, hands off the needed parameters to
  # the Failure module.
  #
  # source://resque/lib/resque/job.rb#232
  def fail(exception); end

  # source://resque/lib/resque/job.rb#277
  def failure_hooks; end

  # @return [Boolean]
  #
  # source://resque/lib/resque/job.rb#219
  def has_payload_class?; end

  # String representation
  #
  # source://resque/lib/resque/job.rb#253
  def inspect; end

  # This job's associated payload object.
  #
  # source://resque/lib/resque/job.rb#74
  def payload; end

  # Returns the actual class constant represented in this job's payload.
  #
  # source://resque/lib/resque/job.rb#208
  def payload_class; end

  # Returns the payload class as a string without raising NameError
  #
  # source://resque/lib/resque/job.rb#213
  def payload_class_name; end

  # Attempts to perform the work represented by this job instance.
  # Calls #perform on the class given in the payload with the
  # arguments given in the payload.
  #
  # source://resque/lib/resque/job.rb#150
  def perform; end

  # The name of the queue from which this job was pulled (or is to be
  # placed)
  #
  # source://resque/lib/resque/job.rb#71
  def queue; end

  # Creates an identical job, essentially placing this job back on
  # the queue.
  #
  # source://resque/lib/resque/job.rb#248
  def recreate; end

  # source://resque/lib/resque/job.rb#17
  def redis; end

  # source://resque/lib/resque/job.rb#281
  def run_failure_hooks(exception); end

  # The worker object which is currently processing this job.
  #
  # source://resque/lib/resque/job.rb#67
  def worker; end

  # The worker object which is currently processing this job.
  #
  # source://resque/lib/resque/job.rb#67
  def worker=(_arg0); end

  class << self
    # Creates a job by placing it on a queue. Expects a string queue
    # name, a string class name, and an optional array of arguments to
    # pass to the class' `perform` method.
    #
    # Raises an exception if no queue or class is given.
    #
    # source://resque_spec/0.18.1lib/resque_spec/ext.rb#10
    def create(queue, klass, *args); end

    # source://resque/lib/resque/job.rb#87
    def create_without_resque_spec(queue, klass, *args); end

    # source://resque/lib/resque/job.rb#26
    def data_store; end

    # Given a string, returns a Ruby object.
    #
    # source://resque/lib/resque/job.rb#48
    def decode(object); end

    # Removes a job from a queue. Expects a string queue name, a
    # string class name, and, optionally, args.
    #
    # Returns the number of jobs destroyed.
    #
    # If no args are provided, it will remove all jobs of the class
    # provided.
    #
    # That is, for these two jobs:
    #
    # { 'class' => 'UpdateGraph', 'args' => ['defunkt'] }
    # { 'class' => 'UpdateGraph', 'args' => ['mojombo'] }
    #
    # The following call will remove both:
    #
    #   Resque::Job.destroy(queue, 'UpdateGraph')
    #
    # Whereas specifying args will only remove the 2nd job:
    #
    #   Resque::Job.destroy(queue, 'UpdateGraph', 'mojombo')
    #
    # This method can be potentially very slow and memory intensive,
    # depending on the size of your queue, as it loads all jobs into
    # a Ruby array before processing.
    #
    # source://resque_spec/0.18.1lib/resque_spec/ext.rb#18
    def destroy(queue, klass, *args); end

    # source://resque/lib/resque/job.rb#123
    def destroy_without_resque_spec(queue, klass, *args); end

    # Given a Ruby object, returns a string suitable for storage in a
    # queue.
    #
    # source://resque/lib/resque/job.rb#43
    def encode(object); end

    # source://resque/lib/resque/job.rb#22
    def redis; end

    # Given a string queue name, returns an instance of Resque::Job
    # if any jobs are available. If not, returns nil.
    #
    # source://resque/lib/resque/job.rb#142
    def reserve(queue); end
  end
end

# Raise Resque::Job::DontPerform from a before_perform hook to
# abort the job.
#
# source://resque/lib/resque/job.rb#64
class Resque::Job::DontPerform < ::StandardError; end

# Include this module in classes you wish to have logging facilities
#
# source://resque/lib/resque/logging.rb#3
module Resque::Logging
  private

  # Log level aliases
  #
  # source://resque/lib/resque/logging.rb#12
  def debug(message); end

  # source://resque/lib/resque/logging.rb#15
  def error(message); end

  # source://resque/lib/resque/logging.rb#16
  def fatal(message); end

  # source://resque/lib/resque/logging.rb#13
  def info(message); end

  # source://resque/lib/resque/logging.rb#14
  def warn(message); end

  class << self
    # Log level aliases
    #
    # source://resque/lib/resque/logging.rb#12
    def debug(message); end

    # source://resque/lib/resque/logging.rb#15
    def error(message); end

    # source://resque/lib/resque/logging.rb#16
    def fatal(message); end

    # source://resque/lib/resque/logging.rb#13
    def info(message); end

    # Thunk to the logger's own log method (if configured)
    #
    # source://resque/lib/resque/logging.rb#7
    def log(severity, message); end

    # source://resque/lib/resque/logging.rb#14
    def warn(message); end
  end
end

# Raised when trying to create a job without a class
#
# source://resque/lib/resque/errors.rb#6
class Resque::NoClassError < ::RuntimeError; end

# Raised whenever we need a queue but none is provided.
#
# source://resque/lib/resque/errors.rb#3
class Resque::NoQueueError < ::RuntimeError; end

# source://resque/lib/resque/plugin.rb#2
module Resque::Plugin
  extend ::Resque::Plugin

  # Given an object, returns a list `after_dequeue` hook names.
  #
  # source://resque/lib/resque/plugin.rb#69
  def after_dequeue_hooks(job); end

  # Given an object, returns a list `after_enqueue` hook names.
  #
  # source://resque/lib/resque/plugin.rb#59
  def after_enqueue_hooks(job); end

  # Given an object, returns a list `after_perform` hook names.
  #
  # source://resque/lib/resque/plugin.rb#49
  def after_hooks(job); end

  # Given an object, returns a list `around_perform` hook names.
  #
  # source://resque/lib/resque/plugin.rb#44
  def around_hooks(job); end

  # Given an object, returns a list `before_dequeue` hook names.
  #
  # source://resque/lib/resque/plugin.rb#74
  def before_dequeue_hooks(job); end

  # Given an object, returns a list `before_enqueue` hook names.
  #
  # source://resque/lib/resque/plugin.rb#64
  def before_enqueue_hooks(job); end

  # Given an object, returns a list `before_perform` hook names.
  #
  # source://resque/lib/resque/plugin.rb#39
  def before_hooks(job); end

  # Given an object, returns a list `on_failure` hook names.
  #
  # source://resque/lib/resque/plugin.rb#54
  def failure_hooks(job); end

  # Given an object, and a method prefix, returns a list of methods prefixed
  # with that name (hook names).
  #
  # source://resque/lib/resque/plugin.rb#33
  def get_hook_names(job, hook_method_prefix); end

  # source://resque/lib/resque/plugin.rb#27
  def job_methods(job); end

  # Ensure that your plugin conforms to good hook naming conventions.
  #
  #   Resque::Plugin.lint(MyResquePlugin)
  #
  # source://resque/lib/resque/plugin.rb#10
  def lint(plugin); end
end

# source://resque/lib/resque/plugin.rb#5
class Resque::Plugin::LintError < ::RuntimeError; end

# source://resque/lib/resque/errors.rb#18
class Resque::PruneDeadWorkerDirtyExit < ::Resque::DirtyExit
  # @return [PruneDeadWorkerDirtyExit] a new instance of PruneDeadWorkerDirtyExit
  #
  # source://resque/lib/resque/errors.rb#19
  def initialize(hostname, job); end
end

# source://resque/lib/resque/log_formatters/quiet_formatter.rb#2
class Resque::QuietFormatter
  # source://resque/lib/resque/log_formatters/quiet_formatter.rb#3
  def call(serverity, datetime, progname, msg); end
end

# source://resque/lib/resque/railtie.rb#2
class Resque::Railtie < ::Rails::Railtie; end

# source://resque/lib/resque/server.rb#14
class Resque::Server < ::Sinatra::Base
  include ::Resque::ServerHelper

  # source://resque/lib/resque/server.rb#175
  def resque; end

  # source://resque/lib/resque/server.rb#31
  def show(page, layout = T.unsafe(nil)); end

  # source://resque/lib/resque/server.rb#40
  def show_for_polling(page); end

  class << self
    # source://sinatra/3.1.0lib/sinatra/base.rb#1344
    def app_file; end

    # source://sinatra/3.1.0lib/sinatra/base.rb#1343
    def app_file=(val); end

    def app_file?; end

    # source://sinatra/3.1.0lib/sinatra/base.rb#1344
    def public_folder; end

    # source://sinatra/3.1.0lib/sinatra/base.rb#1343
    def public_folder=(val); end

    def public_folder?; end
    def static; end

    # source://sinatra/3.1.0lib/sinatra/base.rb#1343
    def static=(val); end

    def static?; end

    # source://resque/lib/resque/server.rb#179
    def tabs; end

    # source://resque/lib/resque/server.rb#187
    def url_prefix; end

    # source://resque/lib/resque/server.rb#183
    def url_prefix=(url_prefix); end

    # source://sinatra/3.1.0lib/sinatra/base.rb#1344
    def views; end

    # source://sinatra/3.1.0lib/sinatra/base.rb#1343
    def views=(val); end

    def views?; end
  end
end

# source://resque/lib/resque/server_helper.rb#4
module Resque::ServerHelper
  include ::Rack::Utils

  # source://resque/lib/resque/server_helper.rb#25
  def class_if_current(path = T.unsafe(nil)); end

  # source://resque/lib/resque/server_helper.rb#12
  def current_page; end

  # source://resque/lib/resque/server_helper.rb#8
  def current_section; end

  # source://resque/lib/resque/server_helper.rb#163
  def failed_class_counts(queue = T.unsafe(nil)); end

  # failed.erb helpers#
  #
  # source://resque/lib/resque/server_helper.rb#124
  def failed_date_format; end

  # source://resque/lib/resque/server_helper.rb#151
  def failed_end_at; end

  # @return [Boolean]
  #
  # source://resque/lib/resque/server_helper.rb#128
  def failed_multiple_queues?; end

  # source://resque/lib/resque/server_helper.rb#159
  def failed_order; end

  # source://resque/lib/resque/server_helper.rb#139
  def failed_per_page; end

  # source://resque/lib/resque/server_helper.rb#135
  def failed_size; end

  # source://resque/lib/resque/server_helper.rb#147
  def failed_start_at; end

  # source://resque/lib/resque/server_helper.rb#173
  def page_entries_info(start, stop, size, name = T.unsafe(nil)); end

  # source://resque/lib/resque/server_helper.rb#104
  def partial(template, local_vars = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://resque/lib/resque/server_helper.rb#100
  def partial?; end

  # source://resque/lib/resque/server_helper.rb#21
  def path_prefix; end

  # source://resque/lib/resque/server_helper.rb#111
  def poll; end

  # source://resque/lib/resque/server_helper.rb#43
  def redis_get_size(key); end

  # source://resque/lib/resque/server_helper.rb#60
  def redis_get_value_as_array(key, start = T.unsafe(nil)); end

  # source://resque/lib/resque/server_helper.rb#77
  def show_args(args); end

  # source://resque/lib/resque/server_helper.rb#29
  def tab(name); end

  # source://resque/lib/resque/server_helper.rb#35
  def tabs; end

  # source://resque/lib/resque/server_helper.rb#16
  def u(*path_parts); end

  # source://resque/lib/resque/server_helper.rb#16
  def url_path(*path_parts); end

  # source://resque/lib/resque/server_helper.rb#39
  def url_prefix; end

  # source://resque/lib/resque/server_helper.rb#85
  def worker_hosts; end

  # source://resque/lib/resque/server_helper.rb#89
  def worker_hosts!; end

  private

  # source://rack/2.2.8lib/rack/utils.rb#184
  def h(string); end
end

# The stat subsystem. Used to keep track of integer counts.
#
#   Get a stat:  Stat[name]
#   Incr a stat: Stat.incr(name)
#   Decr a stat: Stat.decr(name)
#   Kill a stat: Stat.clear(name)
#
# source://resque/lib/resque/stat.rb#8
module Resque::Stat
  extend ::Resque::Stat

  # Increments a stat by one.
  #
  # source://resque/lib/resque/stat.rb#43
  def <<(stat); end

  # Decrements a stat by one.
  #
  # source://resque/lib/resque/stat.rb#56
  def >>(stat); end

  # Alias of `get`
  #
  # source://resque/lib/resque/stat.rb#30
  def [](stat); end

  # Removes a stat from Redis, effectively setting it to 0.
  #
  # source://resque/lib/resque/stat.rb#61
  def clear(stat, **opts); end

  # source://resque/lib/resque/stat.rb#16
  def data_store; end

  # source://resque/lib/resque/stat.rb#20
  def data_store=(data_store); end

  # For a string stat name, decrements the stat by one.
  #
  # Can optionally accept a second int parameter. The stat is then
  # decremented by that amount.
  #
  # source://resque/lib/resque/stat.rb#51
  def decr(stat, by = T.unsafe(nil)); end

  # Returns the int value of a stat, given a string stat name.
  #
  # source://resque/lib/resque/stat.rb#25
  def get(stat); end

  # For a string stat name, increments the stat by one.
  #
  # Can optionally accept a second int parameter. The stat is then
  # incremented by that amount.
  #
  # source://resque/lib/resque/stat.rb#38
  def incr(stat, by = T.unsafe(nil), **opts); end

  # source://resque/lib/resque/stat.rb#11
  def redis; end
end

# Raised when child process is TERM'd so job can rescue this to do shutdown work.
#
# source://resque/lib/resque/errors.rb#26
class Resque::TermException < ::SignalException; end

# source://resque/lib/resque/thread_signal.rb#1
class Resque::ThreadSignal
  # @return [ThreadSignal] a new instance of ThreadSignal
  #
  # source://resque/lib/resque/thread_signal.rb#2
  def initialize; end

  # source://resque/lib/resque/thread_signal.rb#8
  def signal; end

  # source://resque/lib/resque/thread_signal.rb#15
  def wait_for_signal(timeout); end
end

# source://resque/lib/resque/version.rb#2
Resque::VERSION = T.let(T.unsafe(nil), String)

# source://resque/lib/resque/log_formatters/verbose_formatter.rb#2
class Resque::VerboseFormatter
  # source://resque/lib/resque/log_formatters/verbose_formatter.rb#3
  def call(serverity, datetime, progname, msg); end
end

# source://resque/lib/resque/log_formatters/very_verbose_formatter.rb#2
class Resque::VeryVerboseFormatter
  # source://resque/lib/resque/log_formatters/very_verbose_formatter.rb#3
  def call(serverity, datetime, progname, msg); end
end

# A Resque Worker processes jobs. On platforms that support fork(2),
# the worker will fork off a child to process each job. This ensures
# a clean slate when beginning the next job and cuts down on gradual
# memory growth as well as low level failures.
#
# It also ensures workers are always listening to signals from you,
# their master, and can react accordingly.
#
# source://resque/lib/resque/worker.rb#13
class Resque::Worker
  include ::Resque::Helpers
  include ::Resque::Logging
  extend ::Resque::Helpers

  # Workers should be initialized with an array of string queue
  # names. The order is important: a Worker will check the first
  # queue given for a job. If none is found, it will check the
  # second queue name given. If a job is found, it will be
  # processed. Upon completion, the Worker will again check the
  # first queue given, and so forth. In this way the queue list
  # passed to a Worker on startup defines the priorities of queues.
  #
  # If passed a single "*", this Worker will operate on all queues
  # in alphabetical order. Queues can be dynamically added or
  # removed without needing to restart workers using this method.
  #
  # Workers should have `#prepare` called after they are initialized
  # if you are running work on the worker.
  #
  # @return [Worker] a new instance of Worker
  #
  # source://resque/lib/resque/worker.rb#143
  def initialize(*queues); end

  # Is this worker the same as another worker?
  #
  # source://resque/lib/resque/worker.rb#804
  def ==(other); end

  # @return [Boolean]
  #
  # source://resque/lib/resque/worker.rb#568
  def child_already_exited?; end

  # source://resque/lib/resque/worker.rb#24
  def data_store; end

  # Given a string, returns a Ruby object.
  #
  # source://resque/lib/resque/worker.rb#44
  def decode(object); end

  # Called when we are done working - clears our `working_on` state
  # and tells Redis we processed a job.
  #
  # source://resque/lib/resque/worker.rb#728
  def done_working; end

  # Enables GC Optimizations if you're running REE.
  # http://www.rubyenterpriseedition.com/faq.html#adapt_apps_for_cow
  #
  # source://resque/lib/resque/worker.rb#386
  def enable_gc_optimizations; end

  # Given a Ruby object, returns a string suitable for storage in a
  # queue.
  #
  # source://resque/lib/resque/worker.rb#39
  def encode(object); end

  # How many failed jobs has this worker seen? Returns an int.
  #
  # source://resque/lib/resque/worker.rb#754
  def failed; end

  # Tells Redis we've failed a job.
  #
  # source://resque/lib/resque/worker.rb#759
  def failed!; end

  # Sets the attribute fork_per_job
  #
  # @param value the value to set the attribute fork_per_job to.
  #
  # source://resque/lib/resque/worker.rb#65
  def fork_per_job=(_arg0); end

  # @return [Boolean]
  #
  # source://resque/lib/resque/worker.rb#792
  def fork_per_job?; end

  # source://resque/lib/resque/worker.rb#219
  def glob_match(list, pattern); end

  # should term kill workers gracefully (vs. immediately)
  # Makes SIGTERM work like SIGQUIT
  #
  # source://resque/lib/resque/worker.rb#59
  def graceful_term; end

  # should term kill workers gracefully (vs. immediately)
  # Makes SIGTERM work like SIGQUIT
  #
  # source://resque/lib/resque/worker.rb#59
  def graceful_term=(_arg0); end

  # source://resque/lib/resque/worker.rb#484
  def heartbeat; end

  # source://resque/lib/resque/worker.rb#492
  def heartbeat!(time = T.unsafe(nil)); end

  # chomp'd hostname of this worker's machine
  #
  # source://resque/lib/resque/worker.rb#820
  def hostname; end

  # Sets the attribute hostname
  #
  # @param value the value to set the attribute hostname to.
  #
  # source://resque/lib/resque/worker.rb#66
  def hostname=(_arg0); end

  # The string representation is the same as the id for this worker
  # instance. Can be used with `Worker.find`.
  #
  # source://resque/lib/resque/worker.rb#814
  def id; end

  # Boolean - true if idle, false if not
  #
  # @return [Boolean]
  #
  # source://resque/lib/resque/worker.rb#788
  def idle?; end

  # source://resque/lib/resque/worker.rb#808
  def inspect; end

  # Returns a hash explaining the Job we're currently processing, if any.
  #
  # source://resque/lib/resque/worker.rb#775
  def job(reload = T.unsafe(nil)); end

  # Sets the attribute job
  #
  # @param value the value to set the attribute job to.
  #
  # source://resque/lib/resque/worker.rb#779
  def job=(_arg0); end

  # source://resque/lib/resque/worker.rb#675
  def kill_background_threads; end

  # Kills the forked child immediately, without remorse. The job it
  # is processing will not be completed.
  #
  # source://resque/lib/resque/worker.rb#472
  def kill_child; end

  # Find Resque worker pids on Linux and OS X.
  #
  # source://resque/lib/resque/worker.rb#850
  def linux_worker_pids; end

  # source://resque/lib/resque/worker.rb#878
  def log(message); end

  # source://resque/lib/resque/worker.rb#882
  def log!(message); end

  # Kills the forked child immediately with minimal remorse. The job it
  # is processing will not be completed. Send the child a TERM signal,
  # wait <term_timeout> seconds, and then a KILL signal if it has not quit
  # If pre_shutdown_timeout has been set to a positive number, it will allow
  # the child that many seconds before sending the aforementioned TERM and KILL.
  #
  # source://resque-heroku-signals/2.6.0lib/resque-heroku-signals.rb#17
  def new_kill_child; end

  # Stop processing jobs after the current one has completed (if we're
  # currently running one).
  #
  # source://resque/lib/resque/worker.rb#587
  def pause_processing; end

  # are we paused?
  #
  # @return [Boolean]
  #
  # source://resque/lib/resque/worker.rb#581
  def paused?; end

  # Processes a given job in the child.
  #
  # source://resque/lib/resque/worker.rb#316
  def perform(job); end

  # Returns Integer PID of running worker
  #
  # source://resque/lib/resque/worker.rb#825
  def pid; end

  # Sets the attribute pid
  #
  # @param value the value to set the attribute pid to.
  #
  # source://resque/lib/resque/worker.rb#68
  def pid=(_arg0); end

  # Returns the value of attribute pre_shutdown_timeout.
  #
  # source://resque/lib/resque/worker.rb#50
  def pre_shutdown_timeout; end

  # Sets the attribute pre_shutdown_timeout
  #
  # @param value the value to set the attribute pre_shutdown_timeout to.
  #
  # source://resque/lib/resque/worker.rb#50
  def pre_shutdown_timeout=(_arg0); end

  # Daemonizes the worker if ENV['BACKGROUND'] is set and writes
  # the process id to ENV['PIDFILE'] if set. Should only be called
  # once per worker.
  #
  # source://resque/lib/resque/worker.rb#168
  def prepare; end

  # DEPRECATED. Processes a single job. If none is given, it will
  # try to produce one. Usually run in the child.
  #
  # source://resque/lib/resque/worker.rb#289
  def process(job = T.unsafe(nil), &block); end

  # How many jobs has this worker processed? Returns an int.
  #
  # source://resque/lib/resque/worker.rb#743
  def processed; end

  # Tell Redis we've processed a job.
  #
  # source://resque/lib/resque/worker.rb#748
  def processed!(**opts); end

  # Returns a hash explaining the Job we're currently processing, if any.
  #
  # source://resque/lib/resque/worker.rb#775
  def processing(reload = T.unsafe(nil)); end

  # Given a string, sets the procline ($0) and logs.
  # Procline is always in the format of:
  #   RESQUE_PROCLINE_PREFIXresque-VERSION: STRING
  #
  # source://resque/lib/resque/worker.rb#873
  def procline(string); end

  # Looks for any workers which should be running on this server
  # and, if they're not, removes them from Redis.
  #
  # This is a form of garbage collection. If a server is killed by a
  # hard shutdown, power failure, or something else beyond our
  # control, the Resque workers will not die gracefully and therefore
  # will leave stale state information in Redis.
  #
  # By checking the current Redis state against the actual
  # environment, we can determine if Redis is old and clean it up a bit.
  #
  # source://resque/lib/resque/worker.rb#610
  def prune_dead_workers; end

  # Returns a list of queues to use when searching for a job.
  # A splat ("*") means you want every queue (in alpha order) - this
  # can be useful for dynamically adding new queues.
  #
  # source://resque/lib/resque/worker.rb#210
  def queues; end

  # source://resque/lib/resque/worker.rb#182
  def queues=(queues); end

  # Reconnect to Redis to avoid sharing a connection with the parent,
  # retry up to 3 times with increasing delay before giving up.
  #
  # source://resque/lib/resque/worker.rb#352
  def reconnect; end

  # source://resque/lib/resque/worker.rb#24
  def redis; end

  # Registers the various signal handlers a worker responds to.
  #
  # TERM: Shutdown immediately, stop processing jobs.
  #  INT: Shutdown immediately, stop processing jobs.
  # QUIT: Shutdown after the current job has finished processing.
  # USR1: Kill the forked child immediately, continue processing jobs.
  # USR2: Don't process any new jobs
  # CONT: Start processing jobs again after a USR2
  #
  # source://resque/lib/resque/worker.rb#400
  def register_signal_handlers; end

  # Registers ourself as a worker. Useful when entering the worker
  # lifecycle on startup.
  #
  # source://resque/lib/resque/worker.rb#656
  def register_worker; end

  # source://resque/lib/resque/worker.rb#488
  def remove_heartbeat; end

  # Reports the exception and marks the job as failed
  #
  # source://resque/lib/resque/worker.rb#300
  def report_failed_job(job, exception); end

  # Attempts to grab a job off one of the provided queues. Returns
  # nil if no job can be found.
  #
  # source://resque/lib/resque/worker.rb#334
  def reserve; end

  # When set to true, forked workers will exit with `exit`, calling any `at_exit` code handlers that have been
  # registered in the application. Otherwise, forked workers exit with `exit!`
  #
  # source://resque/lib/resque/worker.rb#63
  def run_at_exit_hooks; end

  # When set to true, forked workers will exit with `exit`, calling any `at_exit` code handlers that have been
  # registered in the application. Otherwise, forked workers exit with `exit!`
  #
  # source://resque/lib/resque/worker.rb#63
  def run_at_exit_hooks=(_arg0); end

  # Runs a named hook, passing along any arguments.
  #
  # source://resque/lib/resque/worker.rb#661
  def run_hook(name, *args); end

  # Schedule this worker for shutdown. Will finish processing the
  # current job.
  #
  # source://resque/lib/resque/worker.rb#441
  def shutdown; end

  # Kill the child and shutdown immediately.
  # If not forking, abort this process.
  #
  # source://resque/lib/resque/worker.rb#448
  def shutdown!; end

  # Should this worker shutdown as soon as current job is finished?
  #
  # @return [Boolean]
  #
  # source://resque/lib/resque/worker.rb#466
  def shutdown?; end

  # Find Resque worker pids on Solaris.
  #
  # Returns an Array of string pids of all the other workers on this
  # machine. Useful when pruning dead workers on startup.
  #
  # source://resque/lib/resque/worker.rb#860
  def solaris_worker_pids; end

  # source://resque/lib/resque/worker.rb#522
  def start_heartbeat; end

  # What time did this worker start? Returns an instance of `Time`
  #
  # source://resque/lib/resque/worker.rb#765
  def started; end

  # Tell Redis we've started
  #
  # source://resque/lib/resque/worker.rb#770
  def started!; end

  # Runs all the methods needed when a worker begins its lifecycle.
  #
  # source://resque/lib/resque/worker.rb#369
  def startup; end

  # Returns a symbol representing the current worker state,
  # which can be either :working or :idle
  #
  # source://resque/lib/resque/worker.rb#799
  def state; end

  # source://resque/lib/resque/worker.rb#734
  def state_change; end

  # decide whether to use new_kill_child logic
  #
  # source://resque/lib/resque/worker.rb#55
  def term_child; end

  # decide whether to use new_kill_child logic
  #
  # source://resque/lib/resque/worker.rb#55
  def term_child=(_arg0); end

  # Returns the value of attribute term_child_signal.
  #
  # source://resque/lib/resque/worker.rb#52
  def term_child_signal; end

  # Sets the attribute term_child_signal
  #
  # @param value the value to set the attribute term_child_signal to.
  #
  # source://resque/lib/resque/worker.rb#52
  def term_child_signal=(_arg0); end

  # Returns the value of attribute term_timeout.
  #
  # source://resque/lib/resque/worker.rb#48
  def term_timeout; end

  # Sets the attribute term_timeout
  #
  # @param value the value to set the attribute term_timeout to.
  #
  # source://resque/lib/resque/worker.rb#48
  def term_timeout=(_arg0); end

  # The string representation is the same as the id for this worker
  # instance. Can be used with `Worker.find`.
  #
  # source://resque/lib/resque/worker.rb#814
  def to_s; end

  # Sets the attribute to_s
  #
  # @param value the value to set the attribute to_s to.
  #
  # source://resque/lib/resque/worker.rb#67
  def to_s=(_arg0); end

  # Start processing jobs again after a pause
  #
  # source://resque/lib/resque/worker.rb#594
  def unpause_processing; end

  # source://resque-heroku-signals/2.6.0lib/resque-heroku-signals.rb#42
  def unregister_signal_handlers; end

  # Unregisters ourself as a worker. Useful when shutting down.
  #
  # source://resque/lib/resque/worker.rb#683
  def unregister_worker(exception = T.unsafe(nil)); end

  # A worker must be given a queue, otherwise it won't know what to
  # do with itself.
  #
  # You probably never need to call this.
  #
  # source://resque/lib/resque/worker.rb#201
  def validate_queues; end

  # Returns the value of attribute verbose.
  #
  # source://resque/lib/resque/worker.rb#887
  def verbose; end

  # source://resque/lib/resque/worker.rb#889
  def verbose=(value); end

  # Returns the value of attribute very_verbose.
  #
  # source://resque/lib/resque/worker.rb#887
  def very_verbose; end

  # source://resque/lib/resque/worker.rb#900
  def very_verbose=(value); end

  # source://resque/lib/resque/worker.rb#572
  def wait_for_child_exit(timeout); end

  # Returns an Array of string pids of all the other workers on this
  # machine. Useful when pruning dead workers on startup.
  #
  # source://resque/lib/resque/worker.rb#843
  def windows_worker_pids; end

  # This is the main workhorse method. Called on a Worker instance,
  # it begins the worker life cycle.
  #
  # The following events occur during a worker's life cycle:
  #
  # 1. Startup:   Signals are registered, dead workers are pruned,
  #               and this worker is registered.
  # 2. Work loop: Jobs are pulled from a queue and processed.
  # 3. Teardown:  This worker is unregistered.
  #
  # Can be passed a float representing the polling frequency.
  # The default is 5 seconds, but for a semi-active site you may
  # want to use a smaller value.
  #
  # Also accepts a block which will be passed the job as soon as it
  # has completed processing. Useful for testing.
  #
  # source://resque/lib/resque/worker.rb#242
  def work(interval = T.unsafe(nil), &block); end

  # source://resque/lib/resque/worker.rb#267
  def work_one_job(job = T.unsafe(nil), &block); end

  # Returns an Array of string pids of all the other workers on this
  # machine. Useful when pruning dead workers on startup.
  #
  # source://resque/lib/resque/worker.rb#831
  def worker_pids; end

  # Boolean - true if working, false if not
  #
  # @return [Boolean]
  #
  # source://resque/lib/resque/worker.rb#783
  def working?; end

  # Given a job, tells Redis we're working on it. Useful for seeing
  # what workers are doing and when.
  #
  # source://resque/lib/resque/worker.rb#717
  def working_on(job); end

  private

  # source://resque/lib/resque/worker.rb#944
  def log_with_severity(severity, message); end

  # source://resque/lib/resque/worker.rb#916
  def perform_with_fork(job, &block); end

  class << self
    # Returns an array of all worker objects.
    #
    # source://resque/lib/resque/worker.rb#71
    def all; end

    # source://resque/lib/resque/worker.rb#496
    def all_heartbeats; end

    # Returns a list of workers that have sent a heartbeat in the past, but which
    # already expired (does NOT include workers that have never sent a heartbeat at all).
    #
    # source://resque/lib/resque/worker.rb#502
    def all_workers_with_expired_heartbeats; end

    # Alias of `find`
    #
    # source://resque/lib/resque/worker.rb#119
    def attach(worker_id); end

    # source://resque/lib/resque/worker.rb#33
    def data_store; end

    # Given a string worker id, return a boolean indicating whether the
    # worker exists
    #
    # @return [Boolean]
    #
    # source://resque/lib/resque/worker.rb#125
    def exists?(worker_id); end

    # Returns a single worker object. Accepts a string id.
    #
    # source://resque/lib/resque/worker.rb#102
    def find(worker_id, options = T.unsafe(nil)); end

    # source://resque/lib/resque/worker.rb#19
    def kill_all_heartbeat_threads; end

    # source://resque/lib/resque/worker.rb#29
    def redis; end

    # Returns an array of all worker objects currently processing
    # jobs.
    #
    # source://resque/lib/resque/worker.rb#77
    def working; end
  end
end

# source://resque/lib/resque/worker.rb#180
Resque::Worker::WILDCARDS = T.let(T.unsafe(nil), Array)

# source://resque/lib/resque/vendor/utf8_util.rb#1
module UTF8Util
  class << self
    # Replace invalid UTF-8 character sequences with a replacement character
    #
    # Returns a copy of this String as valid UTF-8.
    #
    # source://resque/lib/resque/vendor/utf8_util.rb#17
    def clean(str); end

    # Replace invalid UTF-8 character sequences with a replacement character
    #
    # Returns self as valid UTF-8.
    #
    # source://resque/lib/resque/vendor/utf8_util.rb#9
    def clean!(str); end
  end
end

# use '?' intsead of the unicode replace char, since that is 3 bytes
# and can increase the string size if it's done a lot
#
# source://resque/lib/resque/vendor/utf8_util.rb#4
UTF8Util::REPLACEMENT_CHAR = T.let(T.unsafe(nil), String)
