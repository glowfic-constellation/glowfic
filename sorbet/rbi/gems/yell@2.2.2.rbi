# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `yell` gem.
# Please instead update this file by running `bin/tapioca gem yell`.


# source://yell//lib/core_ext/logger.rb#3
class Logger
  # source://yell//lib/core_ext/logger.rb#15
  def add(severity, message = T.unsafe(nil), progname = T.unsafe(nil), &block); end

  # source://yell//lib/core_ext/logger.rb#11
  def add_with_yell(severity, message = T.unsafe(nil), progname = T.unsafe(nil), &block); end

  # source://yell//lib/core_ext/logger.rb#14
  def add_without_yell(severity, message = T.unsafe(nil), progname = T.unsafe(nil)); end

  # source://yell//lib/core_ext/logger.rb#9
  def level=(level); end

  # source://yell//lib/core_ext/logger.rb#5
  def level_with_yell=(level); end

  # source://yell//lib/core_ext/logger.rb#8
  def level_without_yell=(severity); end
end

# source://yell//lib/yell.rb#22
module Yell
  class << self
    # Shortcut to Yell::Repository[]
    #
    # @return [Yell::Logger] The logger instance
    #
    # source://yell//lib/yell.rb#46
    def [](name); end

    # Shortcut to Yell::Repository[]=
    #
    # @return [Yell::Logger] The logger instance
    #
    # source://yell//lib/yell.rb#53
    def []=(name, logger); end

    # @private
    #
    # source://yell//lib/yell.rb#90
    def __deprecate__(version, message, options = T.unsafe(nil)); end

    # @private
    #
    # source://yell//lib/yell.rb#106
    def __fetch__(hash, *args); end

    # @private
    #
    # source://yell//lib/yell.rb#99
    def __warn__(*messages); end

    # @private
    #
    # source://yell//lib/yell.rb#77
    def env; end

    # Shortcut to Yell::Fomatter.new
    #
    # @return [Yell::Formatter] A Yell::Formatter instance
    #
    # source://yell//lib/yell.rb#60
    def format(pattern = T.unsafe(nil), date_pattern = T.unsafe(nil), &block); end

    # Shortcut to Yell::Level.new
    #
    # @return [Yell::Level] The level instance
    #
    # source://yell//lib/yell.rb#39
    def level(val = T.unsafe(nil)); end

    # Loads a config from a YAML file
    #
    # @return [Yell::Logger] The logger instance
    #
    # source://yell//lib/yell.rb#67
    def load!(file); end

    # Creates a new logger instance.
    #
    # Refer to #Yell::Loggger for usage.
    #
    # @return [Yell::Logger] The logger instance
    #
    # source://yell//lib/yell.rb#32
    def new(*args, &block); end

    # Shortcut to Yell::Adapters.register
    #
    # source://yell//lib/yell.rb#72
    def register(name, klass); end
  end
end

# AdapterNotFound is raised whenever you want to instantiate an
# adapter that does not exist.
#
# source://yell//lib/yell/adapters.rb#4
class Yell::AdapterNotFound < ::StandardError; end

# This module provides the interface to attaching adapters to
# the logger. You should not have to call the corresponding classes
# directly.
#
# source://yell//lib/yell/adapters.rb#9
module Yell::Adapters
  class << self
    # Returns an instance of the given processor type.
    #
    # @example A simple file adapter
    #   Yell::Adapters.new( :file )
    # @raise [AdapterNotFound]
    #
    # source://yell//lib/yell/adapters.rb#61
    def new(type, options = T.unsafe(nil), &block); end

    # Register your own adapter here
    #
    # @example
    #   Yell::Adapters.register( :myadapter, MyAdapter )
    #
    # source://yell//lib/yell/adapters.rb#53
    def register(name, klass); end
  end
end

# This class provides the basic interface for all allowed operations on any
# adapter implementation. Other adapters should inherit from it for the methods
# used by the {Yell::Logger}.
#
# Writing your own adapter is really simple. Inherit from the base class and use
# the `setup`, `write` and `close` methods. Yell requires the `write` method to be
# specified (`setup` and `close` are optional).
#
#
# The following example shows how to define a basic Adapter to format and print
# log events to STDOUT:
#
#   class PutsAdapter < Yell::Adapters::Base
#     include Yell::Formatter::Helpers
#
#     setup do |options|
#       self.format = options[:format]
#     end
#
#     write do |event|
#       message = format.call(event)
#
#       STDOUT.puts message
#     end
#   end
#
#
# After the Adapter has been written, we need to register it to Yell:
#
#   Yell::Adapters.register :puts, PutsAdapter
#
# Now, we can use it like so:
#
#   logger = Yell.new :puts
#   logger.info "Hello World!"
#
# source://yell//lib/yell/adapters/base.rb#41
class Yell::Adapters::Base < ::Monitor
  include ::Yell::Helpers::Base
  include ::Yell::Helpers::Level

  # Initializes a new Adapter.
  #
  # You should not overload the constructor, use #setup instead.
  #
  # @return [Base] a new instance of Base
  #
  # source://yell//lib/yell/adapters/base.rb#136
  def initialize(options = T.unsafe(nil), &block); end

  # Close the adapter (stream, connection, etc).
  #
  # Adapter classes should provide their own implementation
  # of this method.
  #
  # source://yell//lib/yell/adapters/base.rb#163
  def close; end

  # Get a pretty string representation of the adapter, including
  #
  # source://yell//lib/yell/adapters/base.rb#168
  def inspect; end

  # The main method for calling the adapter.
  #
  # The method receives the log `event` and determines whether to
  # actually write or not.
  #
  # source://yell//lib/yell/adapters/base.rb#150
  def write(event); end

  private

  # Perform the actual close.
  #
  # Adapter classes should provide their own implementation
  # of this method.
  #
  # source://yell//lib/yell/adapters/base.rb#204
  def close!; end

  # Get an array of inspected attributes for the adapter.
  #
  # source://yell//lib/yell/adapters/base.rb#221
  def inspectables; end

  # Perform the actual open.
  #
  # Adapter classes should provide their own implementation
  # of this method.
  #
  # source://yell//lib/yell/adapters/base.rb#196
  def open!; end

  # Setup the adapter instance.
  #
  # Adapter classes should provide their own implementation
  # of this method (if applicable).
  #
  # source://yell//lib/yell/adapters/base.rb#180
  def setup!(options); end

  # Perform the actual write.
  #
  # Adapter classes must provide their own implementation
  # of this method.
  #
  # source://yell//lib/yell/adapters/base.rb#188
  def write!(event); end

  # Determine whether to write at the given severity.
  #
  # @example
  #   write? Yell::Event.new( 'INFO', 'Hello Wold!' )
  # @param event [Yell::Event] The log event
  # @return [Boolean] true or false
  #
  # source://yell//lib/yell/adapters/base.rb#216
  def write?(event); end

  class << self
    # Define your close method with this helper.
    #
    # @example Closing a file handle
    #   close do
    #   @stream.close
    #   end
    #
    # source://yell//lib/yell/adapters/base.rb#82
    def close(&block); end

    # Define your open method with this helper.
    #
    # @example Open a file handle
    #   open do
    #   @stream = ::File.open( 'test.log', ::File::WRONLY|::File::APPEND|::File::CREAT )
    #   end
    #
    # source://yell//lib/yell/adapters/base.rb#72
    def open(&block); end

    # Setup your adapter with this helper method.
    #
    # @example
    #   setup do |options|
    #   @file_handle = File.new( '/dev/null', 'w' )
    #   end
    #
    # source://yell//lib/yell/adapters/base.rb#52
    def setup(&block); end

    # Define your write method with this helper.
    #
    # @example Printing messages to file
    #   write do |event|
    #   @file_handle.puts event.message
    #   end
    #
    # source://yell//lib/yell/adapters/base.rb#62
    def write(&block); end

    private

    # Pretty funky code block, I know but here is what it basically does:
    #
    # @example
    #   compile! :write! do |event|
    #   puts event.message
    #   end
    #
    #   # Is actually defining the `:write!` instance method with a call to super:
    #
    #   def write!( event )
    #   puts event.method
    #   super
    #   end
    #
    # source://yell//lib/yell/adapters/base.rb#102
    def compile!(name, &block); end

    # Define instance method by given name and call the unbound
    # methods in order with provided block.
    #
    # source://yell//lib/yell/adapters/base.rb#117
    def define!(name, _m, m, &block); end
  end
end

# source://yell//lib/yell/adapters.rb#10
class Yell::Adapters::Collection
  # @return [Collection] a new instance of Collection
  #
  # source://yell//lib/yell/adapters.rb#11
  def initialize(options = T.unsafe(nil)); end

  # source://yell//lib/yell/adapters.rb#16
  def add(type = T.unsafe(nil), *args, &block); end

  # @private
  #
  # source://yell//lib/yell/adapters.rb#41
  def close; end

  # @return [Boolean]
  #
  # source://yell//lib/yell/adapters.rb#30
  def empty?; end

  # @private
  #
  # source://yell//lib/yell/adapters.rb#35
  def write(event); end
end

# The +Datefile+ adapter is similar to the +File+ adapter. However, it
# rotates the file at midnight (by default).
#
# source://yell//lib/yell/adapters/datefile.rb#6
class Yell::Adapters::Datefile < ::Yell::Adapters::File
  # The pattern to be used for the files
  #
  # @example
  #   date_pattern = "%Y%m%d"       # default
  #   date_pattern = "%Y-week-%V"
  #
  # source://yell//lib/yell/adapters/datefile.rb#20
  def date_pattern; end

  # The pattern to be used for the files
  #
  # @example
  #   date_pattern = "%Y%m%d"       # default
  #   date_pattern = "%Y-week-%V"
  #
  # source://yell//lib/yell/adapters/datefile.rb#20
  def date_pattern=(_arg0); end

  # You can suppress the first line of the logfile that contains
  # the metadata. This is important upon rollover, because on *nix
  # systems, it is not possible to determine the creation time of a file,
  # on the last access time. The header compensates this.
  #
  # @example
  #   header = false
  #
  # source://yell//lib/yell/adapters/datefile.rb#48
  def header; end

  # You can suppress the first line of the logfile that contains
  # the metadata. This is important upon rollover, because on *nix
  # systems, it is not possible to determine the creation time of a file,
  # on the last access time. The header compensates this.
  #
  # @example
  #   header = false
  #
  # source://yell//lib/yell/adapters/datefile.rb#48
  def header=(_arg0); end

  # Set the amount of logfiles to keep when rolling over.
  # By default, no files will be cleaned up.
  #
  # @example Do not clean up any files
  #   keep = 0
  # @example Keep the last 5 logfiles
  #   keep = 5
  #   keep = '10'
  #
  # source://yell//lib/yell/adapters/datefile.rb#39
  def keep; end

  # Set the amount of logfiles to keep when rolling over.
  # By default, no files will be cleaned up.
  #
  # @example Do not clean up any files
  #   keep = 0
  # @example Keep the last 5 logfiles
  #   keep = 5
  #   keep = '10'
  #
  # source://yell//lib/yell/adapters/datefile.rb#39
  def keep=(_arg0); end

  # Tell the adapter to create a symlink onto the currently
  # active (timestamped) file. Upon rollover, the symlink is
  # set to the newly created file, and so on.
  #
  # @example
  #   symlink = true
  #
  # source://yell//lib/yell/adapters/datefile.rb#28
  def symlink; end

  # Tell the adapter to create a symlink onto the currently
  # active (timestamped) file. Upon rollover, the symlink is
  # set to the newly created file, and so on.
  #
  # @example
  #   symlink = true
  #
  # source://yell//lib/yell/adapters/datefile.rb#28
  def symlink=(_arg0); end

  private

  # Removes old logfiles of the same date pattern.
  #
  # By reading the header of the files that match the date pattern, the
  # adapter determines whether to remove them or not. If no header is present,
  # it makes the best guess by checking the last access time (which may result
  # in false cleanups).
  #
  # source://yell//lib/yell/adapters/datefile.rb#117
  def cleanup!; end

  # Cleanup old logfiles?
  #
  # @return [Boolean] true or false
  #
  # source://yell//lib/yell/adapters/datefile.rb#132
  def cleanup?; end

  # @overload close!
  #
  # source://yell//lib/yell/adapters/datefile.rb#86
  def close!; end

  # Determine whether to close the file handle or not.
  #
  # It is based on the `:date_pattern` (can be passed as option upon initialize).
  # If the current time hits the pattern, it closes the file stream.
  #
  # @return [Boolean] true or false
  #
  # source://yell//lib/yell/adapters/datefile.rb#98
  def close?; end

  # Sets the filename with the `:date_pattern` appended to it.
  #
  # source://yell//lib/yell/adapters/datefile.rb#165
  def filename_for(date); end

  # Write the header information into the file
  #
  # source://yell//lib/yell/adapters/datefile.rb#153
  def header!; end

  # Write header into the file?
  #
  # @return [Boolean] true or false
  #
  # source://yell//lib/yell/adapters/datefile.rb#160
  def header?; end

  # Fetch the header form the file
  #
  # source://yell//lib/yell/adapters/datefile.rb#170
  def header_from(file); end

  # @overload inspectables
  #
  # source://yell//lib/yell/adapters/datefile.rb#184
  def inspectables; end

  # @overload setup!
  #
  # source://yell//lib/yell/adapters/datefile.rb#54
  def setup!(options); end

  # Symlink the current filename to the original one.
  #
  # source://yell//lib/yell/adapters/datefile.rb#137
  def symlink!; end

  # Symlink the original filename?
  #
  # @return [Boolean] true or false
  #
  # source://yell//lib/yell/adapters/datefile.rb#148
  def symlink?; end

  # @overload write!
  #
  # source://yell//lib/yell/adapters/datefile.rb#70
  def write!(event); end
end

# The default date pattern, e.g. "19820114" (14 Jan 1982)
#
# source://yell//lib/yell/adapters/datefile.rb#9
Yell::Adapters::Datefile::DefaultDatePattern = T.let(T.unsafe(nil), String)

# Metadata
#
# source://yell//lib/yell/adapters/datefile.rb#12
Yell::Adapters::Datefile::Header = T.let(T.unsafe(nil), Proc)

# source://yell//lib/yell/adapters/datefile.rb#13
Yell::Adapters::Datefile::HeaderRegexp = T.let(T.unsafe(nil), Regexp)

# The +File+ adapter is the most basic. As one would expect, it's used
# for logging into files.
#
# source://yell//lib/yell/adapters/file.rb#6
class Yell::Adapters::File < ::Yell::Adapters::Io
  private

  # source://yell//lib/yell/adapters/file.rb#24
  def default_filename; end

  # @overload open!
  #
  # source://yell//lib/yell/adapters/file.rb#18
  def open!; end

  # @overload setup!
  #
  # source://yell//lib/yell/adapters/file.rb#11
  def setup!(options); end
end

# source://yell//lib/yell/adapters/io.rb#3
class Yell::Adapters::Io < ::Yell::Adapters::Base
  include ::Yell::Helpers::Formatter

  # Shortcut to enable colors.
  #
  # @example
  #   colorize!
  #
  # source://yell//lib/yell/adapters/io.rb#36
  def colorize!; end

  # Sets colored output on or off (default off)
  #
  # @example Disable colors
  #   colors = false
  # @example Enable colors
  #   colors = true
  #
  # source://yell//lib/yell/adapters/io.rb#30
  def colors; end

  # Sets colored output on or off (default off)
  #
  # @example Disable colors
  #   colors = false
  # @example Enable colors
  #   colors = true
  #
  # source://yell//lib/yell/adapters/io.rb#30
  def colors=(_arg0); end

  # Sets the “sync mode” to true or false.
  #
  # When true (default), every log event is immediately written to the file.
  # When false, the log event is buffered internally.
  #
  # source://yell//lib/yell/adapters/io.rb#21
  def sync; end

  # Sets the “sync mode” to true or false.
  #
  # When true (default), every log event is immediately written to the file.
  # When false, the log event is buffered internally.
  #
  # source://yell//lib/yell/adapters/io.rb#21
  def sync=(_arg0); end

  private

  # @overload close!
  #
  # source://yell//lib/yell/adapters/io.rb#75
  def close!; end

  # @overload inspectables
  #
  # source://yell//lib/yell/adapters/io.rb#91
  def inspectables; end

  # @overload open!
  #
  # source://yell//lib/yell/adapters/io.rb#67
  def open!; end

  # @overload setup!
  #
  # source://yell//lib/yell/adapters/io.rb#42
  def setup!(options); end

  # The IO stream
  #
  # Adapter classes should provide their own implementation
  # of this method.
  #
  # source://yell//lib/yell/adapters/io.rb#86
  def stream; end

  # @overload write!
  #
  # source://yell//lib/yell/adapters/io.rb#53
  def write!(event); end
end

# The possible unix log colors
#
# source://yell//lib/yell/adapters/io.rb#7
Yell::Adapters::Io::TTYColors = T.let(T.unsafe(nil), Hash)

# source://yell//lib/yell/adapters/streams.rb#16
class Yell::Adapters::Stderr < ::Yell::Adapters::Io
  private

  # @overload open!
  #
  # source://yell//lib/yell/adapters/streams.rb#21
  def open!; end
end

# source://yell//lib/yell/adapters/streams.rb#4
class Yell::Adapters::Stdout < ::Yell::Adapters::Io
  private

  # @overload open!
  #
  # source://yell//lib/yell/adapters/streams.rb#9
  def open!; end
end

# Basic Format
#
# @example
#   logger = Yell.new STDOUT, format: Yell::BasicFormat
#   logger.info "Hello World!"
#   #=> "I, 2012-02-29T09:30:00+01:00 : Hello World!"
#   #    ^  ^                          ^
#   #    ^  ISO8601 Timestamp          Message
#   #    Level (short)
#
# source://yell//lib/yell/formatter.rb#40
Yell::BasicFormat = T.let(T.unsafe(nil), String)

# The Configuration can be used to setup Yell before
# initializing an instance.
#
# source://yell//lib/yell/configuration.rb#8
class Yell::Configuration
  class << self
    # source://yell//lib/yell/configuration.rb#10
    def load!(file); end
  end
end

# Default Format
#
# @example
#   logger = Yell.new STDOUT, format: Yell::DefaultFormat
#   logger.info "Hello World!"
#   #=> "2012-02-29T09:30:00+01:00 [ INFO] 65784 : Hello World!"
#   #    ^                         ^       ^       ^
#   #    ISO8601 Timestamp         Level   Pid     Message
#
# source://yell//lib/yell/formatter.rb#29
Yell::DefaultFormat = T.let(T.unsafe(nil), String)

# Yell::Event.new( :info, 'Hello World', { :scope => 'Application' } )
# #=> Hello World scope: Application
#
# source://yell//lib/yell/event.rb#8
class Yell::Event
  # @return [Event] a new instance of Event
  #
  # source://yell//lib/yell/event.rb#52
  def initialize(logger, options, *messages); end

  # Accessor to filename the log event occured
  #
  # source://yell//lib/yell/event.rb#89
  def file; end

  # Accessor to the hostname
  #
  # source://yell//lib/yell/event.rb#69
  def hostname; end

  # Accessor to the log level
  #
  # source://yell//lib/yell/event.rb#40
  def level; end

  # Accessor to the line the log event occured
  #
  # source://yell//lib/yell/event.rb#94
  def line; end

  # Accessor to the log message
  #
  # source://yell//lib/yell/event.rb#43
  def messages; end

  # Accessor to the method the log event occured
  #
  # source://yell//lib/yell/event.rb#99
  def method; end

  # Accessor to the logger's name
  #
  # source://yell//lib/yell/event.rb#49
  def name; end

  # Accessor to the PID
  #
  # source://yell//lib/yell/event.rb#79
  def pid; end

  # Accessor to the progname
  #
  # source://yell//lib/yell/event.rb#74
  def progname; end

  # Accessor to the thread's id
  #
  # source://yell//lib/yell/event.rb#84
  def thread_id; end

  # Accessor to the time the log event occured
  #
  # source://yell//lib/yell/event.rb#46
  def time; end

  private

  # source://yell//lib/yell/event.rb#120
  def backtrace!; end

  # source://yell//lib/yell/event.rb#116
  def caller_index; end

  # source://yell//lib/yell/event.rb#106
  def extract!(options); end
end

# jruby and rubinius seem to have a different caller
#
# source://yell//lib/yell/event.rb#13
Yell::Event::CallerIndex = T.let(T.unsafe(nil), Integer)

# regex to fetch caller attributes
#
# source://yell//lib/yell/event.rb#10
Yell::Event::CallerRegexp = T.let(T.unsafe(nil), Regexp)

# source://yell//lib/yell/event.rb#16
class Yell::Event::Options
  include ::Comparable

  # @return [Options] a new instance of Options
  #
  # source://yell//lib/yell/event.rb#22
  def initialize(severity, caller_offset); end

  # source://yell//lib/yell/event.rb#27
  def <=>(other); end

  # Returns the value of attribute caller_offset.
  #
  # source://yell//lib/yell/event.rb#20
  def caller_offset; end

  # Returns the value of attribute severity.
  #
  # source://yell//lib/yell/event.rb#19
  def severity; end

  # Returns the value of attribute severity.
  #
  # source://yell//lib/yell/event.rb#31
  def to_i; end

  # Returns the value of attribute severity.
  #
  # source://yell//lib/yell/event.rb#32
  def to_int; end
end

# Extended Format
#
# @example
#   logger = Yell.new STDOUT, format: Yell::ExtendedFormat
#   logger.info "Hello World!"
#   #=> "2012-02-29T09:30:00+01:00 [ INFO] 65784 localhost : Hello World!"
#   #    ^                          ^      ^     ^           ^
#   #    ISO8601 Timestamp          Level  Pid   Hostname    Message
#
# source://yell//lib/yell/formatter.rb#50
Yell::ExtendedFormat = T.let(T.unsafe(nil), String)

# The +Formatter+ provides a handle to configure your log message style.
#
# source://yell//lib/yell/formatter.rb#54
class Yell::Formatter
  # Initializes a new +Yell::Formatter+.
  #
  # Upon initialization it defines a format method. `format` takes
  # a {Yell::Event} instance as agument in order to apply for desired log
  # message formatting.
  #
  # @example Blank formatter
  #   Formatter.new
  # @example Formatter with a message and date pattern
  #   Formatter.new("%d [%5L] %p : %m", "%D %H:%M:%S.%L")
  # @example Formatter with a message modifier
  #   Formatter.new do |f|
  #   f.modify(Hash) { |h| "Hash: #{h.inspect}" }
  #   end
  # @example Formatter with a message pattern
  #   Formatter.new("%d [%5L] %p : %m")
  # @return [Formatter] a new instance of Formatter
  #
  # source://yell//lib/yell/formatter.rb#107
  def initialize(*args, &block); end

  # Returns the value of attribute date_pattern.
  #
  # source://yell//lib/yell/formatter.rb#85
  def date_pattern; end

  # Get a pretty string
  #
  # source://yell//lib/yell/formatter.rb#119
  def inspect; end

  # Returns the value of attribute pattern.
  #
  # source://yell//lib/yell/formatter.rb#85
  def pattern; end

  private

  # define a standard +Logger+ backwards compatible #call method for the formatter
  #
  # source://yell//lib/yell/formatter.rb#195
  def define_call_method!; end

  # source://yell//lib/yell/formatter.rb#179
  def define_date_method!; end

  # source://yell//lib/yell/formatter.rb#221
  def level(sev, length = T.unsafe(nil)); end

  # source://yell//lib/yell/formatter.rb#230
  def message(messages); end

  # do nothing
  #
  # source://yell//lib/yell/formatter.rb#235
  def noop; end

  # source://yell//lib/yell/formatter.rb#203
  def to_sprintf(table); end
end

# Builder class to allow setters that won't be accessible once
# transferred to the Formatter
#
# source://yell//lib/yell/formatter.rb#155
class Yell::Formatter::Builder
  # @return [Builder] a new instance of Builder
  #
  # source://yell//lib/yell/formatter.rb#159
  def initialize(pattern = T.unsafe(nil), date_pattern = T.unsafe(nil), &block); end

  # Returns the value of attribute date_pattern.
  #
  # source://yell//lib/yell/formatter.rb#156
  def date_pattern; end

  # Sets the attribute date_pattern
  #
  # @param value the value to set the attribute date_pattern to.
  #
  # source://yell//lib/yell/formatter.rb#156
  def date_pattern=(_arg0); end

  # Returns the value of attribute modifier.
  #
  # source://yell//lib/yell/formatter.rb#157
  def modifier; end

  # source://yell//lib/yell/formatter.rb#174
  def modify(key, &block); end

  # Returns the value of attribute pattern.
  #
  # source://yell//lib/yell/formatter.rb#156
  def pattern; end

  # Sets the attribute pattern
  #
  # @param value the value to set the attribute pattern to.
  #
  # source://yell//lib/yell/formatter.rb#156
  def pattern=(_arg0); end
end

# For standard formatted backwards compatibility
#
# source://yell//lib/yell/formatter.rb#73
Yell::Formatter::LegacyTable = T.let(T.unsafe(nil), Hash)

# Message modifier class to allow different modifiers for different requirements.
#
# source://yell//lib/yell/formatter.rb#127
class Yell::Formatter::Modifier
  # @return [Modifier] a new instance of Modifier
  #
  # source://yell//lib/yell/formatter.rb#128
  def initialize; end

  # source://yell//lib/yell/formatter.rb#136
  def call(message); end

  # source://yell//lib/yell/formatter.rb#132
  def set(key, &block); end
end

# source://yell//lib/yell/formatter.rb#82
Yell::Formatter::PatternMatcher = T.let(T.unsafe(nil), Regexp)

# source://yell//lib/yell/formatter.rb#56
Yell::Formatter::Table = T.let(T.unsafe(nil), Hash)

# source://yell//lib/yell/helpers/base.rb#2
module Yell::Helpers; end

# source://yell//lib/yell/helpers/adapter.rb#3
module Yell::Helpers::Adapter
  # Define an adapter to be used for logging.
  #
  # @example Set the adapter directly from an adapter instance
  #   adapter Yell::Adapter::File.new
  # @example Standard adapter
  #   adapter :file
  # @example Standard adapter with filename
  #   adapter :file, 'development.log'
  #
  #   # Alternative notation for filename in options
  #   adapter :file, filename: 'developent.log'
  # @example Standard adapter with filename and additional options
  #   adapter :file, 'development.log', level: :warn
  # @param type [Symbol] The type of the adapter, may be `:file` or `:datefile` (default `:file`)
  # @raise [Yell::NoSuchAdapter] Will be thrown when the adapter is not defined
  # @return [Yell::Adapter] The instance
  #
  # source://yell//lib/yell/helpers/adapter.rb#24
  def adapter(type = T.unsafe(nil), *args, &block); end

  # source://yell//lib/yell/helpers/adapter.rb#28
  def adapters; end

  private

  # source://yell//lib/yell/helpers/adapter.rb#34
  def reset!; end
end

# source://yell//lib/yell/helpers/base.rb#3
module Yell::Helpers::Base
  private

  # source://yell//lib/yell/helpers/base.rb#11
  def inspectables; end

  # stub
  #
  # source://yell//lib/yell/helpers/base.rb#8
  def reset!; end
end

# source://yell//lib/yell/helpers/formatter.rb#3
module Yell::Helpers::Formatter
  # source://yell//lib/yell/helpers/formatter.rb#17
  def format; end

  # Set the format for your message.
  #
  # source://yell//lib/yell/helpers/formatter.rb#12
  def format=(pattern); end

  # source://yell//lib/yell/helpers/formatter.rb#14
  def formatter; end

  # Set the format for your message.
  #
  # source://yell//lib/yell/helpers/formatter.rb#6
  def formatter=(pattern); end

  private

  # source://yell//lib/yell/helpers/formatter.rb#22
  def reset!; end
end

# source://yell//lib/yell/helpers/level.rb#3
module Yell::Helpers::Level
  # @private
  #
  # source://yell//lib/yell/helpers/level.rb#19
  def level; end

  # Set the minimum log level.
  #
  # @example Set the level to :warn
  #   level = :warn
  # @param severity [String, Symbol, Integer] The minimum log level
  #
  # source://yell//lib/yell/helpers/level.rb#11
  def level=(severity); end

  private

  # source://yell//lib/yell/helpers/level.rb#32
  def inspectables; end

  # source://yell//lib/yell/helpers/level.rb#26
  def reset!; end
end

# source://yell//lib/yell/helpers/silencer.rb#3
module Yell::Helpers::Silencer
  # Set the silence pattern
  #
  # source://yell//lib/yell/helpers/silencer.rb#6
  def silence(*patterns); end

  # source://yell//lib/yell/helpers/silencer.rb#10
  def silencer; end

  private

  # source://yell//lib/yell/helpers/silencer.rb#17
  def reset!; end

  # source://yell//lib/yell/helpers/silencer.rb#23
  def silence!(*messages); end
end

# source://yell//lib/yell/helpers/tracer.rb#3
module Yell::Helpers::Tracer
  # source://yell//lib/yell/helpers/tracer.rb#27
  def trace; end

  # Set whether the logger should allow tracing or not. The trace option
  # will tell the logger when to provider caller information.
  #
  # @example No tracing at all
  #   trace = false
  # @example Trace every time
  #   race = true
  # @example Trace from the error level onwards
  #   trace = :error
  #   trace = 'gte.error'
  # @return [Yell::Level] a level representation of the tracer
  #
  # source://yell//lib/yell/helpers/tracer.rb#19
  def trace=(severity); end

  private

  # source://yell//lib/yell/helpers/tracer.rb#40
  def inspectables; end

  # source://yell//lib/yell/helpers/tracer.rb#34
  def reset!; end
end

# The +Level+ class handles the severities for you in order to determine
# if an adapter should log or not.
#
# In order to setup your level, you have certain modifiers available:
#   at :warn    # will be set to :warn level only
#   gt :warn    # Will set from :error level onwards
#   gte :warn   # Will set from :warn level onwards
#   lt :warn    # Will set from :info level an below
#   lte :warn   # Will set from :warn level and below
#
# You are able to combine those modifiers to your convenience.
#
# @example Set at :info only
#   Yell::Level.new.at(:info)
# @example Set from :info to :error (excluding)
#   Yell::Level.new(:info).lt(:error)
# @example Set from :info to :error (including)
#   Yell::Level.new(:info).lte(:error)
#
# source://yell//lib/yell/level.rb#23
class Yell::Level
  include ::Comparable

  # Create a new level instance.
  #
  # @example Enable all severities
  #   Yell::Level.new
  # @example Pass a range to set the level within the severities
  #   Yell::Level.new (:info..:error)
  # @example Pass an array to exactly set the level at the given severities
  #   Yell::Level.new [:info, :error]
  # @example Pass the minimum possible severity
  #   Yell::Level.new :warn
  # @param severity [Integer, String, Symbol, Array, Range, nil] The severity for the level.
  # @return [Level] a new instance of Level
  #
  # source://yell//lib/yell/level.rb#43
  def initialize(*severities); end

  # @private
  #
  # source://yell//lib/yell/level.rb#153
  def <=>(other); end

  # @private
  #
  # source://yell//lib/yell/level.rb#148
  def ==(other); end

  # Set the level at specific severities
  #
  # @example Set at :debug and :error only
  #   at :debug, :error
  # @return [Yell::Level] the instance
  #
  # source://yell//lib/yell/level.rb#81
  def at(*severities); end

  # Returns whether the level is allowed at the given severity
  #
  # @example
  #   at? :warn
  #   at? 0       # debug
  # @return [Boolean] tru or false
  #
  # source://yell//lib/yell/level.rb#69
  def at?(severity); end

  # Set the level to greater than the given severity
  #
  # @example Set to :error and above
  #   gt :warn
  # @return [Yell::Level] the instance
  #
  # source://yell//lib/yell/level.rb#92
  def gt(severity); end

  # Set the level greater or equal to the given severity
  #
  # @example Set to :warn and above
  #   gte :warn
  # @return [Yell::Level] the instance
  #
  # source://yell//lib/yell/level.rb#103
  def gte(severity); end

  # Get a pretty string representation of the level, including the severities.
  #
  # source://yell//lib/yell/level.rb#137
  def inspect; end

  # Set the level lower than given severity
  #
  # @example Set to lower than :warn
  #   lt :warn
  # @return [Yell::Level] the instance
  #
  # source://yell//lib/yell/level.rb#114
  def lt(severity); end

  # Set the level lower or equal than given severity
  #
  # @example Set to lower or equal than :warn
  #   lte :warn
  # @return [Yell::Level] the instance
  #
  # source://yell//lib/yell/level.rb#125
  def lte(severity); end

  # Set the severity to the given format
  #
  # source://yell//lib/yell/level.rb#49
  def set(*severities); end

  # @private
  #
  # source://yell//lib/yell/level.rb#143
  def severities; end

  # to_i implements backwards compatibility
  #
  # source://yell//lib/yell/level.rb#131
  def to_i; end

  # to_i implements backwards compatibility
  #
  # source://yell//lib/yell/level.rb#134
  def to_int; end

  private

  # source://yell//lib/yell/level.rb#190
  def ascending!(index); end

  # source://yell//lib/yell/level.rb#168
  def calculate!(modifier, severity); end

  # source://yell//lib/yell/level.rb#194
  def descending!(index); end

  # source://yell//lib/yell/level.rb#198
  def each; end

  # source://yell//lib/yell/level.rb#183
  def index_from(severity); end

  # source://yell//lib/yell/level.rb#160
  def interpret(severities); end

  # source://yell//lib/yell/level.rb#206
  def set!(index, val = T.unsafe(nil)); end
end

# source://yell//lib/yell/level.rb#26
Yell::Level::InterpretRegexp = T.let(T.unsafe(nil), Regexp)

# Include this module to add a logger to any class.
#
# When including this module, your class will have a :logger instance method
# available. Before you can use it, you will need to define a Yell logger and
# provide it with the name of your class.
#
# @example
#   Yell.new :stdout, name: 'Foo'
#
#   class Foo
#   include Yell::Loggable
#   end
#
#   Foo.new.logger.info "Hello World"
#
# source://yell//lib/yell/loggable.rb#16
module Yell::Loggable
  mixes_in_class_methods ::Yell::Loggable::ClassMethods

  # source://yell//lib/yell/loggable.rb#27
  def logger; end

  class << self
    # @private
    #
    # source://yell//lib/yell/loggable.rb#17
    def included(base); end
  end
end

# source://yell//lib/yell/loggable.rb#21
module Yell::Loggable::ClassMethods
  # source://yell//lib/yell/loggable.rb#22
  def logger; end
end

# The +Yell::Logger+ is your entrypoint. Anything onwards is derived from here.
#
# A +Yell::Logger+ instance holds all your adapters and sends the log events
# to them if applicable. There are multiple ways of how to create a new logger.
#
# source://yell//lib/yell/logger.rb#8
class Yell::Logger
  include ::Yell::Helpers::Base
  include ::Yell::Helpers::Level
  include ::Yell::Helpers::Formatter
  include ::Yell::Helpers::Adapter
  include ::Yell::Helpers::Tracer
  include ::Yell::Helpers::Silencer

  # Initialize a new Logger
  #
  # @example A standard datefile logger
  #   Yell::Logger.new :datefile
  #   Yell::Logger.new :datefile, 'development.log'
  # @example A standard file logger
  #   Yell::Logger.new 'development.log'
  # @example Combined settings
  #   Yell::Logger.new 'development.log', level: :warn
  #
  #   Yell::Logger.new :datefile, 'development.log' do |l|
  #   l.level = :info
  #   end
  # @example Setting the log level
  #   Yell::Logger.new level: :warn
  #
  #   Yell::Logger.new do |l|
  #   l.level = :warn
  #   end
  # @return [Logger] a new instance of Logger
  #
  # source://yell//lib/yell/logger.rb#41
  def initialize(*args, &block); end

  # Somewhat backwards compatible method (not fully though)
  #
  # source://yell//lib/yell/logger.rb#87
  def add(options, *messages, &block); end

  # @private
  #
  # source://yell//lib/yell/logger.rb#125
  def close; end

  # source://yell//lib/yell/logger.rb#108
  def debug(*m, &b); end

  # source://yell//lib/yell/logger.rb#108
  def debug?; end

  # source://yell//lib/yell/logger.rb#108
  def error(*m, &b); end

  # source://yell//lib/yell/logger.rb#108
  def error?; end

  # source://yell//lib/yell/logger.rb#108
  def fatal(*m, &b); end

  # source://yell//lib/yell/logger.rb#108
  def fatal?; end

  # source://yell//lib/yell/logger.rb#108
  def info(*m, &b); end

  # source://yell//lib/yell/logger.rb#108
  def info?; end

  # Get a pretty string representation of the logger.
  #
  # source://yell//lib/yell/logger.rb#119
  def inspect; end

  # The name of the logger instance
  #
  # source://yell//lib/yell/logger.rb#17
  def name; end

  # Set the name of a logger. When providing a name, the logger will
  # automatically be added to the Yell::Repository.
  #
  # @return [String] The logger's name
  #
  # source://yell//lib/yell/logger.rb#79
  def name=(val); end

  # source://yell//lib/yell/logger.rb#108
  def unknown(*m, &b); end

  # source://yell//lib/yell/logger.rb#108
  def unknown?; end

  # source://yell//lib/yell/logger.rb#108
  def warn(*m, &b); end

  # source://yell//lib/yell/logger.rb#108
  def warn?; end

  # @private
  #
  # source://yell//lib/yell/logger.rb#130
  def write(event); end

  private

  # The :adapters key may be passed to the options hash. It may appear in
  # multiple variations:
  #
  # @example
  #   extract!(:stdout, :stderr)
  # @example
  #   extract!(stdout: {level: :info}, stderr: {level: :error})
  #
  # source://yell//lib/yell/logger.rb#144
  def extract!(*list); end

  # Get an array of inspected attributes for the adapter.
  #
  # source://yell//lib/yell/logger.rb#155
  def inspectables; end
end

# source://yell//lib/yell/repository.rb#6
class Yell::LoggerNotFound < ::StandardError
  # source://yell//lib/yell/repository.rb#7
  def message; end
end

# No format on the log message
#
# @example
#   logger = Yell.new STDOUT, format: false
#   logger.info "Hello World!"
#   #=> "Hello World!"
#
# source://yell//lib/yell/formatter.rb#19
Yell::NoFormat = T.let(T.unsafe(nil), String)

# source://yell//lib/yell/repository.rb#10
class Yell::Repository
  include ::Singleton::SingletonInstanceMethods
  include ::Singleton
  extend ::MonitorMixin
  extend ::Singleton::SingletonClassMethods

  # @return [Repository] a new instance of Repository
  #
  # source://yell//lib/yell/repository.rb#14
  def initialize; end

  # Fetch the logger by the given name.
  #
  # If the logger could not be found and has a superclass, it
  # will attempt to look there. This is important for the
  # Yell::Loggable module.
  #
  # @private
  #
  # source://yell//lib/yell/repository.rb#58
  def __fetch__(name); end

  # @private
  #
  # source://yell//lib/yell/repository.rb#47
  def loggers; end

  class << self
    # Get loggers from the repository
    #
    # @example Get the logger
    #   Yell::Repository[ 'development' ]
    # @raise [Yell::LoggerNotFound] Raised when repository does not have that key
    # @return [Yell::Logger] The logger instance
    #
    # source://yell//lib/yell/repository.rb#35
    def [](name); end

    # Set loggers in the repository
    #
    # @example Set a logger
    #   Yell::Repository[ 'development' ] = Yell::Logger.new :stdout
    # @return [Yell::Logger] The logger instance
    #
    # source://yell//lib/yell/repository.rb#24
    def []=(name, logger); end

    # Get the list of all loggers in the repository
    #
    # @return [Hash] The map of loggers
    #
    # source://yell//lib/yell/repository.rb#42
    def loggers; end

    private

    # source://yell//lib/yell/repository.rb#12
    def allocate; end

    # source://yell//lib/yell/repository.rb#12
    def new(*_arg0); end
  end
end

# Holds all Yell severities
#
# source://yell//lib/yell.rb#24
Yell::Severities = T.let(T.unsafe(nil), Array)

# The +Yell::Silencer+ is your handly helper for stiping out unwanted log messages.
#
# source://yell//lib/yell/silencer.rb#4
class Yell::Silencer
  # @return [Silencer] a new instance of Silencer
  #
  # source://yell//lib/yell/silencer.rb#15
  def initialize(*patterns); end

  # Add one or more patterns to the silencer
  #
  # @example
  #   add( 'password' )
  #   add( 'username', 'password' )
  # @example Add regular expressions
  #   add( /password/ )
  # @return [self] The silencer instance
  #
  # source://yell//lib/yell/silencer.rb#29
  def add(*patterns); end

  # Clears out all the messages that would match any defined pattern
  #
  # @example
  #   call(['username', 'password'])
  #   #=> ['username]
  # @return [Array] The remaining messages
  #
  # source://yell//lib/yell/silencer.rb#42
  def call(*messages); end

  # Get a pretty string
  #
  # source://yell//lib/yell/silencer.rb#49
  def inspect; end

  # @private
  #
  # source://yell//lib/yell/silencer.rb#54
  def patterns; end

  private

  # source://yell//lib/yell/silencer.rb#61
  def add!(pattern); end

  # source://yell//lib/yell/silencer.rb#65
  def fetch(pattern); end

  # Check if the provided message matches any of the defined patterns.
  #
  # @example
  #   matches?('password')
  #   #=> true
  # @return [Boolean] true or false
  #
  # source://yell//lib/yell/silencer.rb#79
  def matches?(message); end
end

# source://yell//lib/yell/silencer.rb#6
class Yell::Silencer::PresetNotFound < ::StandardError
  # source://yell//lib/yell/silencer.rb#7
  def message; end
end

# source://yell//lib/yell/silencer.rb#10
Yell::Silencer::Presets = T.let(T.unsafe(nil), Hash)
